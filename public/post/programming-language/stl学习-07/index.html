<!doctype html><html lang=zh dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>STL学习 07 | Pluto's blog</title>
<meta name=keywords content="STL,Cpp"><meta name=description content="十三、STL函数
beg为序列的初始地址
end为序列的尾地址
accumulate
accumulate(beg, end, init)
复杂度: O(N)
作用：对一个序列的元素求和
init为对序列元素求和的初始值
返回值类型：与init 相同


基础累加求和："><meta name=author content="ZhaoYang"><link rel=canonical href=http://localhost:1313/post/programming-language/stl%E5%AD%A6%E4%B9%A0-07/><link crossorigin=anonymous href=/assets/css/stylesheet.858555f7aa71b704d9e49b3e04281f89b8ea905b374c06d322709cb2c4c85423.css integrity="sha256-hYVV96pxtwTZ5Js+BCgfibjqkFs3TAbTInCcssTIVCM=" rel="preload stylesheet" as=style><link rel=icon href=https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/b_0b65080deefa163507d3aa4c6a7a5e07.jpg><link rel=icon type=image/png sizes=16x16 href=https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/b_0b65080deefa163507d3aa4c6a7a5e07.jpg><link rel=icon type=image/png sizes=32x32 href=https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/b_0b65080deefa163507d3aa4c6a7a5e07.jpg><link rel=apple-touch-icon href=https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/b_0b65080deefa163507d3aa4c6a7a5e07.jpg><link rel=mask-icon href=https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/b_0b65080deefa163507d3aa4c6a7a5e07.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=http://localhost:1313/post/programming-language/stl%E5%AD%A6%E4%B9%A0-07/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/post/programming-language/stl%E5%AD%A6%E4%B9%A0-07/"><meta property="og:site_name" content="Pluto's blog"><meta property="og:title" content="STL学习 07"><meta property="og:description" content="十三、STL函数 beg为序列的初始地址
end为序列的尾地址
accumulate accumulate(beg, end, init) 复杂度: O(N)
作用：对一个序列的元素求和
init为对序列元素求和的初始值
返回值类型：与init 相同
基础累加求和："><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-03-24T11:30:03+00:00"><meta property="article:modified_time" content="2023-03-24T11:30:03+00:00"><meta property="article:tag" content="STL"><meta property="article:tag" content="Cpp"><meta property="og:image" content="http://localhost:1313/opengraph.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/opengraph.webp"><meta name=twitter:title content="STL学习 07"><meta name=twitter:description content="十三、STL函数
beg为序列的初始地址
end为序列的尾地址
accumulate
accumulate(beg, end, init)
复杂度: O(N)
作用：对一个序列的元素求和
init为对序列元素求和的初始值
返回值类型：与init 相同


基础累加求和："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/post/"},{"@type":"ListItem","position":2,"name":"STL学习 07","item":"http://localhost:1313/post/programming-language/stl%E5%AD%A6%E4%B9%A0-07/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"STL学习 07","name":"STL学习 07","description":"十三、STL函数 beg为序列的初始地址\nend为序列的尾地址\naccumulate accumulate(beg, end, init) 复杂度: O(N)\n作用：对一个序列的元素求和\ninit为对序列元素求和的初始值\n返回值类型：与init 相同\n基础累加求和：\n","keywords":["STL","Cpp"],"articleBody":"十三、STL函数 beg为序列的初始地址\nend为序列的尾地址\naccumulate accumulate(beg, end, init) 复杂度: O(N)\n作用：对一个序列的元素求和\ninit为对序列元素求和的初始值\n返回值类型：与init 相同\n基础累加求和：\nint a[]={1, 3, 5, 9, 10}; //对[0,2]区间求和，初始值为0，结果为0 + 1 + 3 + 5 = 9 int res1 = accumulate(a, a + 3, 0); //对[0,3]区间求和，初始值为5，结果为5 + 1 + 3 + 5 + 9 = 23 int res2 = accumulate(a, a + 4, 5); 自定义二元对象求和\n使用lambda表达式\ntypedef long long ll; struct node { ll num; } st[10]; for(int i = 1; i \u003c= n; i++) st[i].num = i + 10000000000; //返回值类型与init一致，同时注意参数类型（a）也要一样 //初始值为1，累加1+10000000001+10000000002+10000000003=30000000007 ll res = accumulate(st + 1, st + 4, 1ll, [](ll a,node b) { return a + b.num; }); atoi atoi(const char *) 将字符串转换为int类型\n注意参数为char型数组，如果需要将string类型转换为int类型，可以使用stoi函数（参考下文），或者将string类型转换为const char *类型。\n关于输出数字的范围： atoi不做范围检查，如果超出上界，输出上界，超出下界，输出下界。 stoi会做范围检查，默认必须在int范围内，如果超出范围，会出现RE（Runtime Error）错误。\nstring s = \"1234\"; int a = atoi(s.c_str()); cout \u003c\u003c a \u003c\u003c \"\\n\"; // 1234 或者\nchar s[] = \"1234\"; int a = atoi(s); cout \u003c\u003c a \u003c\u003c \"\\n\"; fill fill(beg, end, num) 复杂度： O(N)\n一个序列进行初始化赋值\n//对a数组的所有元素赋1 int a[5]; fill(a, a + 5, 1); for(int i = 0; i \u003c 5; i++) cout \u003c\u003c a[i] \u003c\u003c \" \"; //1 1 1 1 1 注意区分memset：\nmemset()是按字节进行赋值，对于初始化赋0或-1有比较好的效果.\n如果赋某个特定的数会出错，赋值特定的数建议使用fill()\nis_sorted is_sorted(beg, end) 复杂度： O (N)\n判断序列是否有序（升序），返回bool值\n//如果序列有序，输出YES if(is_sorted(a, a + n)) cout \u003c\u003c \"YES\\n\"; iota iota(beg, end) 让序列递增赋值\nvector\u003cint\u003e a(10); iota(a.begin(), a.end(), 0); for(auto i : a) cout \u003c\u003c i \u003c\u003c \" \"; // 0 1 2 3 4 5 6 7 8 9 lower_bound + upper_bound 复杂度： O(logN)\n作用：二分查找\n//在a数组中查找第一个大于等于x的元素，返回该元素的地址 lower_bound(a, a + n, x); //在a数组中查找第一个大于x的元素，返回该元素的地址 upper_bound(a, a + n, x); //如果未找到，返回尾地址的下一个位置的地址 max_element+min_element 复杂度： O(N)\n找最大最小值\n//函数都是返回地址，需要加*取值 int mx = *max_element(a, a + n); int mn = *min_element(a, a + n); max+min 复杂度： O(1) 找多个元素的最大值和最小值\n//找a，b的最大值和最小值 mx = max(a, b); mn = min(a, b); //找到a,b,c,d的最大值和最小值 mx = max({a, b, c, d}); mn = min({a, b, c, d}); minmax 复杂度： O(1)\n返回一个pair类型，第一个元素是min(a, b)， 第二个元素是max(a, b)\npair\u003cint, int\u003e t = minmax(4, 2); // t.first = 2, t.second = 4 minmax_element minmax_element(beg, end) 复杂度： O(N)\n返回序列中的最小和最大值组成pair的对应的地址，返回类型为pair","wordCount":"3699","inLanguage":"zh","image":"http://localhost:1313/opengraph.webp","datePublished":"2023-03-24T11:30:03Z","dateModified":"2023-03-24T11:30:03Z","author":{"@type":"Person","name":"ZhaoYang"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/post/programming-language/stl%E5%AD%A6%E4%B9%A0-07/"},"publisher":{"@type":"Organization","name":"Pluto's blog","logo":{"@type":"ImageObject","url":"https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/b_0b65080deefa163507d3aa4c6a7a5e07.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Pluto (Alt + H)"><img src=https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/null-20a43f960b8c8f08.jpg alt aria-label=logo height=35>Pluto</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/ title=Home><span>Home</span></a></li><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://github.com/1-pluto1/ title=GitHub><span>GitHub</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>主页</a>&nbsp;»&nbsp;<a href=http://localhost:1313/post/>Posts</a></div><h1 class="post-title entry-hint-parent">STL学习 07</h1><div class=post-meta><span title='2023-03-24 11:30:03 +0000 +0000'>2023年03月24日</span>&nbsp;·&nbsp;8 分钟&nbsp;·&nbsp;3699 字&nbsp;·&nbsp;ZhaoYang&nbsp;|&nbsp;<a href=https://github.com/1-pluto1/hugo-pluto-blog/edit/main/content/post/Programming%20Language/STL%e5%ad%a6%e4%b9%a0%2007.md rel="noopener noreferrer edit" target=_blank>Edit on GitHub</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#十三stl函数>十三、STL函数</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h3 id=十三stl函数>十三、STL函数<a hidden class=anchor aria-hidden=true href=#十三stl函数>#</a></h3><p><code>beg</code>为序列的初始地址</p><p><code>end</code>为序列的尾地址</p><h4 id=accumulate><strong>accumulate</strong><a hidden class=anchor aria-hidden=true href=#accumulate>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>accumulate</span><span class=p>(</span><span class=n>beg</span><span class=p>,</span> <span class=n>end</span><span class=p>,</span> <span class=n>init</span><span class=p>)</span>
</span></span></code></pre></div><p>复杂度: O(N)</p><p>作用：对一个序列的元素求和</p><p><code>init</code>为对序列元素求和的<strong>初始值</strong></p><p>返回值类型：与<code>init</code> 相同</p><ul><li><p><strong>基础累加求和：</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span><span class=p>[]</span><span class=o>=</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>9</span><span class=p>,</span> <span class=mi>10</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//对[0,2]区间求和，初始值为0，结果为0 + 1 + 3 + 5 = 9
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>res1</span> <span class=o>=</span> <span class=n>accumulate</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>a</span> <span class=o>+</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//对[0,3]区间求和，初始值为5，结果为5 + 1 + 3 + 5 + 9 = 23
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>res2</span> <span class=o>=</span> <span class=n>accumulate</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>a</span> <span class=o>+</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>);</span>
</span></span></code></pre></div></li><li><p><strong>自定义二元对象求和</strong></p><p>使用lambda表达式</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>ll</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>node</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ll</span> <span class=n>num</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>st</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>st</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>num</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>10000000000</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>//返回值类型与init一致，同时注意参数类型（a）也要一样
</span></span></span><span class=line><span class=cl><span class=c1>//初始值为1，累加1+10000000001+10000000002+10000000003=30000000007
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ll</span> <span class=n>res</span> <span class=o>=</span> <span class=n>accumulate</span><span class=p>(</span><span class=n>st</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>st</span> <span class=o>+</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>1ll</span><span class=p>,</span> <span class=p>[](</span><span class=n>ll</span> <span class=n>a</span><span class=p>,</span><span class=n>node</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>.</span><span class=n>num</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></div></li></ul><h4 id=atoi><strong>atoi</strong><a hidden class=anchor aria-hidden=true href=#atoi>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>atoi</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=p>)</span>
</span></span></code></pre></div><p>将字符串转换为<code>int</code>类型</p><p>注意参数为<code>char</code>型数组，如果需要将string类型转换为int类型，可以使用<code>stoi</code>函数（参考下文），或者将<code>string</code>类型转换为<code>const char *</code>类型。</p><p>关于输出数字的范围：
<code>atoi</code><strong>不做</strong>范围检查，如果超出上界，输出上界，超出下界，输出下界。
<code>stoi</code><strong>会做</strong>范围检查，默认必须在<code>int</code>范围内，如果超出范围，会出现RE（Runtime Error）错误。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>string</span> <span class=n>s</span> <span class=o>=</span> <span class=s>&#34;1234&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=n>atoi</span><span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>c_str</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=c1>// 1234
</span></span></span></code></pre></div><p>或者</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>char</span> <span class=n>s</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;1234&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=n>atoi</span><span class=p>(</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span></code></pre></div><h4 id=fill><strong>fill</strong><a hidden class=anchor aria-hidden=true href=#fill>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>fill</span><span class=p>(</span><span class=n>beg</span><span class=p>,</span> <span class=n>end</span><span class=p>,</span> <span class=n>num</span><span class=p>)</span>
</span></span></code></pre></div><p>复杂度： O(N)</p><p>一个序列进行初始化赋值</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//对a数组的所有元素赋1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>a</span><span class=p>[</span><span class=mi>5</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>fill</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>a</span> <span class=o>+</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>//1 1 1 1 1
</span></span></span></code></pre></div><p>注意区分memset：</p><p><code>memset()</code>是按<strong>字节</strong>进行赋值，对于初始化赋<code>0</code>或<code>-1</code>有比较好的效果.</p><p>如果赋某个特定的数会<strong>出错</strong>，赋值特定的数建议使用<code>fill()</code></p><h4 id=is_><strong>is_sorted</strong><a hidden class=anchor aria-hidden=true href=#is_>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>is_sorted</span><span class=p>(</span><span class=n>beg</span><span class=p>,</span> <span class=n>end</span><span class=p>)</span>
</span></span></code></pre></div><p>复杂度： O (N)</p><p>判断序列是否有序（升序），返回<code>bool</code>值</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//如果序列有序，输出YES
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span><span class=p>(</span><span class=n>is_sorted</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>a</span> <span class=o>+</span> <span class=n>n</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;YES</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span></code></pre></div><h4 id=iota><strong>iota</strong><a hidden class=anchor aria-hidden=true href=#iota>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>iota</span><span class=p>(</span><span class=n>beg</span><span class=p>,</span> <span class=n>end</span><span class=p>)</span>
</span></span></code></pre></div><p>让序列递增赋值</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>a</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>iota</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>a</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=k>auto</span> <span class=nl>i</span> <span class=p>:</span> <span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>i</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// 0 1 2 3 4 5 6 7 8 9
</span></span></span></code></pre></div><h4 id=lower_><strong>lower_bound + upper_bound</strong><a hidden class=anchor aria-hidden=true href=#lower_>#</a></h4><p>复杂度： O(logN)</p><p>作用：二分查找</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//在a数组中查找第一个大于等于x的元素，返回该元素的地址
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>lower_bound</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>a</span> <span class=o>+</span> <span class=n>n</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//在a数组中查找第一个大于x的元素，返回该元素的地址
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>upper_bound</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>a</span> <span class=o>+</span> <span class=n>n</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//如果未找到，返回尾地址的下一个位置的地址
</span></span></span></code></pre></div><h4 id=max_><strong>max_element+min_element</strong><a hidden class=anchor aria-hidden=true href=#max_>#</a></h4><p>复杂度： O(N)</p><p>找最大最小值</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//函数都是返回地址，需要加*取值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>mx</span> <span class=o>=</span> <span class=o>*</span><span class=n>max_element</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>a</span> <span class=o>+</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>mn</span> <span class=o>=</span> <span class=o>*</span><span class=n>min_element</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>a</span> <span class=o>+</span> <span class=n>n</span><span class=p>);</span>
</span></span></code></pre></div><h4 id=maxmin><strong>max+min</strong><a hidden class=anchor aria-hidden=true href=#maxmin>#</a></h4><p>复杂度： O(1)
找多个元素的最大值和最小值</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//找a，b的最大值和最小值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>mx</span> <span class=o>=</span> <span class=n>max</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>mn</span> <span class=o>=</span> <span class=n>min</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//找到a,b,c,d的最大值和最小值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>mx</span> <span class=o>=</span> <span class=n>max</span><span class=p>({</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>,</span> <span class=n>d</span><span class=p>});</span>
</span></span><span class=line><span class=cl><span class=n>mn</span> <span class=o>=</span> <span class=n>min</span><span class=p>({</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>,</span> <span class=n>d</span><span class=p>});</span>
</span></span></code></pre></div><h4 id=minmax><strong>minmax</strong><a hidden class=anchor aria-hidden=true href=#minmax>#</a></h4><p>复杂度： O(1)</p><p>返回一个<code>pair</code>类型，第一个元素是<code>min(a, b)</code>， 第二个元素是<code>max(a, b)</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>t</span> <span class=o>=</span> <span class=n>minmax</span><span class=p>(</span><span class=mi>4</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// t.first = 2, t.second = 4
</span></span></span></code></pre></div><h4 id=minmax_><strong>minmax_element</strong><a hidden class=anchor aria-hidden=true href=#minmax_>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>minmax_element</span><span class=p>(</span><span class=n>beg</span><span class=p>,</span> <span class=n>end</span><span class=p>)</span>
</span></span></code></pre></div><p>复杂度： O(N)</p><p>返回序列中的最小和最大值组成pair的对应的地址，返回类型为<code>pair&lt;vector&lt;int>::iterator, vector&lt;int>::iterator></code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>a</span><span class=p>(</span><span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>iota</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>a</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>t</span> <span class=o>=</span> <span class=n>minmax_element</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>a</span><span class=p>.</span><span class=n>end</span><span class=p>());</span> <span class=c1>// 返回的是最小值和最大值对应的地址
</span></span></span><span class=line><span class=cl><span class=c1>// *t.first = 1, *t.second = 10 输出对应最小最大值时需要使用指针
</span></span></span></code></pre></div><h4 id=nth_><strong>nth_element</strong><a hidden class=anchor aria-hidden=true href=#nth_>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>nth_element</span><span class=p>(</span><span class=n>beg</span><span class=p>,</span> <span class=n>nth</span><span class=p>,</span> <span class=n>end</span><span class=p>)</span>
</span></span></code></pre></div><p>复杂度： 平均O(N)</p><p>寻找第序列第n小的值</p><p><code>nth</code>为一个迭代器，指向序列中的一个元素。第n小的值恰好在<code>nth</code>位置上。</p><p>执行<code>nth_element()</code>之后，序列中的元素会围绕nth进行划分：<strong>nth之前的元素都小于等于它，而之后的元素都大于等于它</strong></p><p><strong>实例：求序列中的第3小的元素</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>nth_element</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>a</span> <span class=o>+</span> <span class=mi>2</span><span class=p>,</span> <span class=n>a</span> <span class=o>+</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>a</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span></code></pre></div><h4 id=next_><strong>next_permutation</strong><a hidden class=anchor aria-hidden=true href=#next_>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>next_permutation</span><span class=p>(</span><span class=n>beg</span><span class=p>,</span> <span class=n>end</span><span class=p>)</span>
</span></span></code></pre></div><p>复杂度： O(N)</p><p>求序列的下一个排列，下一个排列是字典序大一号的排列</p><p>返回<code>true</code>或<code>false</code></p><ul><li><p><code>next_permutation(beg, end)</code></p><p>如果是最后一个排列，返回<code>false</code>,否则求出下一个序列后，返回<code>true</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//对a序列进行重排
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>next_permutation</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>a</span> <span class=o>+</span> <span class=n>n</span><span class=p>);</span>
</span></span></code></pre></div><p><strong>应用：求所有的排列</strong></p><p>输出<code>a</code>的所有排列</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 数组a不一定是最小字典序序列，一定注意将它排序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>sort</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>a</span> <span class=o>+</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> 	<span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%d &#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>while</span><span class=p>(</span><span class=n>next_permutation</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>a</span> <span class=o>+</span> <span class=n>n</span><span class=p>));</span>
</span></span></code></pre></div></li><li><p><code>prev_permutation(beg, end)</code></p><p>求出前一个排列，如果序列为最小的排列，将其重排为最大的排列，返回false</p></li></ul><h4 id=partial_><strong>partial_sort</strong><a hidden class=anchor aria-hidden=true href=#partial_>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>partial_sort</span><span class=p>(</span><span class=n>beg</span><span class=p>,</span> <span class=n>mid</span><span class=p>,</span> <span class=n>end</span><span class=p>)</span>
</span></span></code></pre></div><p>复杂度： 大概O(NlogM) M为距离</p><p>部分排序,排序mid-beg个元素，mid为要排序区间元素的尾后的一个位置</p><p>从beg到mid<strong>前</strong>的元素都排好序</p><p>对a数组前5个元素排序按从小到大排序</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>5</span><span class=p>,</span><span class=mi>4</span><span class=p>,</span><span class=mi>7</span><span class=p>,</span><span class=mi>9</span><span class=p>,</span><span class=mi>8</span><span class=p>,</span><span class=mi>10</span><span class=p>,</span><span class=mi>6</span><span class=p>,</span><span class=mi>3</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>partial_sort</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>a</span> <span class=o>+</span> <span class=mi>5</span><span class=p>,</span> <span class=n>a</span> <span class=o>+</span> <span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39; &#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>//1 2 3 4 5 9 8 10 7 6
</span></span></span><span class=line><span class=cl><span class=c1>//前五个元素都有序
</span></span></span></code></pre></div><p>也可以添加自定义排序规则:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>partial_sort</span><span class=p>(</span><span class=n>beg</span><span class=p>,</span><span class=n>mid</span><span class=p>,</span><span class=n>end</span><span class=p>,</span><span class=n>cmp</span><span class=p>)</span>
</span></span></code></pre></div><p>对a的前五个元素都是降序排列</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>5</span><span class=p>,</span><span class=mi>4</span><span class=p>,</span><span class=mi>7</span><span class=p>,</span><span class=mi>9</span><span class=p>,</span><span class=mi>8</span><span class=p>,</span><span class=mi>10</span><span class=p>,</span><span class=mi>6</span><span class=p>,</span><span class=mi>3</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>partial_sort</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>a</span> <span class=o>+</span> <span class=mi>5</span><span class=p>,</span> <span class=n>a</span> <span class=o>+</span> <span class=mi>10</span><span class=p>,</span> <span class=n>greater</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39; &#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>//10 9 8 7 6 1 2 4 5 3
</span></span></span><span class=line><span class=cl><span class=c1>//前五个元素降序有序
</span></span></span></code></pre></div><h4 id=random_><strong>random_shuffle</strong><a hidden class=anchor aria-hidden=true href=#random_>#</a></h4><p>复杂度： O(N)</p><ol><li>随机打乱序列的顺序</li><li><code>random_shuffle</code> 在 <code>C++14</code> 中被弃用，在 <code>C++17</code> 中被废除，C++11之后应尽量使用<code>shuffle</code>来代替。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>b</span><span class=p>(</span><span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>iota</span><span class=p>(</span><span class=n>b</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>b</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=mi>1</span><span class=p>);</span><span class=c1>// 序列b递增赋值 1, 2, 3, 4,...
</span></span></span><span class=line><span class=cl><span class=c1>// 对a数组随机重排
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>random_shuffle</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>a</span> <span class=o>+</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// C++11之后尽量使用shuffle
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>shuffle</span><span class=p>(</span><span class=n>b</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>b</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>
</span></span></code></pre></div><h4 id=reverse->**reverse **<a hidden class=anchor aria-hidden=true href=#reverse->#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>reverse</span><span class=p>(</span><span class=n>beg</span><span class=p>,</span><span class=n>end</span><span class=p>)</span>
</span></span></code></pre></div><p>复杂度： O(N)</p><p>对序列进行翻转</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>string</span> <span class=n>s</span> <span class=o>=</span> <span class=s>&#34;abcde&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>reverse</span><span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>s</span><span class=p>.</span><span class=n>end</span><span class=p>());</span><span class=c1>//对s进行翻转
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>s</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span><span class=c1>//edcba
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>//对a数组进行翻转
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>a</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>reverse</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>a</span> <span class=o>+</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>a</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=n>a</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=n>a</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=n>a</span><span class=p>[</span><span class=mi>3</span><span class=p>];</span><span class=c1>//4321
</span></span></span></code></pre></div><h4 id=set_><strong>set_union, set_intersection,set_difference</strong><a hidden class=anchor aria-hidden=true href=#set_>#</a></h4><p>复杂度： O(N+M)</p><p>求两个集合的并集，交集，差集。手动实现双指针就可以搞定，嫌麻烦可以使用该函数。</p><p><strong>注意</strong>：两个集合必须为有序集合，所以下面演示代码使用了排序。vector容器可以替换成set容器，因为set自动会对元素进行排序。</p><p>函数的参数有五个，前两个为第一个容器的首尾迭代器，第三四个为第二个容器的首尾迭代器，最后一个为插入位置，即将结果插入到哪个地址之后。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>a</span> <span class=o>=</span> <span class=p>{</span><span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>8</span><span class=p>},</span> <span class=n>b</span> <span class=o>=</span> <span class=p>{</span><span class=mi>5</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>9</span><span class=p>,</span> <span class=mi>2</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>sort</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>a</span><span class=p>.</span><span class=n>end</span><span class=p>());</span> <span class=c1>// 1 2 4 5 8
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>sort</span><span class=p>(</span><span class=n>b</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>b</span><span class=p>.</span><span class=n>end</span><span class=p>());</span> <span class=c1>// 2 3 5 8 9
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>c</span><span class=p>,</span> <span class=n>d</span><span class=p>,</span> <span class=n>e</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// a并b：1 2 3 4 5 8 9
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>set_union</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>a</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>b</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>b</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>inserter</span><span class=p>(</span><span class=n>c</span><span class=p>,</span> <span class=n>c</span><span class=p>.</span><span class=n>begin</span><span class=p>()));</span>
</span></span><span class=line><span class=cl><span class=c1>// a交b：2 5 8
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>set_intersection</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>a</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>b</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>b</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>inserter</span><span class=p>(</span><span class=n>d</span><span class=p>,</span> <span class=n>d</span><span class=p>.</span><span class=n>begin</span><span class=p>()));</span>
</span></span><span class=line><span class=cl><span class=c1>// a差b： 1 4
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>set_difference</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>a</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>b</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>b</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>inserter</span><span class=p>(</span><span class=n>e</span><span class=p>,</span> <span class=n>e</span><span class=p>.</span><span class=n>begin</span><span class=p>()));</span>
</span></span></code></pre></div><h4 id=sort><strong>sort</strong><a hidden class=anchor aria-hidden=true href=#sort>#</a></h4><p>复杂度： O(NlogN)</p><p>作用：对一个序列进行排序</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//原型：
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>sort</span><span class=p>(</span><span class=n>beg</span><span class=p>,</span> <span class=n>end</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>sort</span><span class=p>(</span><span class=n>beg</span><span class=p>,</span> <span class=n>end</span><span class=p>,</span> <span class=n>cmp</span><span class=p>);</span>
</span></span></code></pre></div><p>几种排序的常见操作：</p><ul><li><p>操作一：对数组正常升序排序</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span><span class=p>[</span><span class=n>N</span><span class=p>];</span> <span class=c1>// 普通数组定义
</span></span></span><span class=line><span class=cl><span class=c1>// 对 a 数组的[1, n]位置进行从小到大排序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>sort</span><span class=p>(</span><span class=n>a</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>a</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>+</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>b</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span> <span class=c1>// vector数组定义
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>sort</span><span class=p>(</span><span class=n>b</span><span class=p>.</span><span class=n>begin</span><span class=p>()</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>b</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>
</span></span></code></pre></div></li><li><p>操作二：使用第三个参数，进行降序排序</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//对a数组的[0, n-1]位置从大到小排序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>sort</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>a</span> <span class=o>+</span> <span class=n>n</span><span class=p>,</span> <span class=n>greater</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=c1>//对a数组的[0, n-1]位置从小到大排序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>sort</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>a</span> <span class=o>+</span> <span class=n>n</span><span class=p>,</span> <span class=n>less</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>b</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>sort</span><span class=p>(</span><span class=n>b</span><span class=p>.</span><span class=n>begin</span><span class=p>()</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>b</span><span class=p>.</span><span class=n>end</span><span class=p>());</span> <span class=c1>// 升序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>sort</span><span class=p>(</span><span class=n>b</span><span class=p>.</span><span class=n>begin</span><span class=p>()</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>b</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>greater</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>());</span> <span class=c1>// 降序
</span></span></span></code></pre></div></li><li><p>操作三：另外一种降序排序方法，针对 <code>vector</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>a</span><span class=p>(</span><span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>sort</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>rbegin</span><span class=p>(),</span> <span class=n>a</span><span class=p>.</span><span class=n>rend</span><span class=p>());</span> <span class=c1>// 使用反向迭代器进行降序排序
</span></span></span></code></pre></div></li><li><p>操作四：自定义排序规则</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 1. 使用函数自定义排序，定义比较函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=nf>cmp</span><span class=p>(</span><span class=n>node</span> <span class=n>a</span><span class=p>,</span> <span class=n>node</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//按结构体里面的x值降序排列
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>a</span><span class=p>.</span><span class=n>x</span> <span class=o>&gt;</span> <span class=n>b</span><span class=p>.</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>sort</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>node</span> <span class=o>+</span> <span class=n>n</span><span class=p>,</span> <span class=n>cmp</span><span class=p>);</span> <span class=c1>// 只能接受 以函数为形式的自定义排序规则，无法接受以结构体为形式的自定义排序规则
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 2. 或者使用匿名函数自定义排序规则
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>sort</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>node</span> <span class=o>+</span> <span class=n>n</span><span class=p>,</span> <span class=p>[](</span><span class=n>node</span> <span class=n>a</span><span class=p>,</span> <span class=n>node</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span><span class=p>.</span><span class=n>x</span> <span class=o>&gt;</span> <span class=n>b</span><span class=p>.</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></div></li></ul><h4 id=stable_><strong>stable_sort</strong><a hidden class=anchor aria-hidden=true href=#stable_>#</a></h4><p>复杂度： O(NlogN)</p><p>功能和 <code>sort()</code> 基本一样</p><p>区别在于<code>stable_sort()</code>能够保证相等元素的相对位置，排序时不会改变相等元素的相对位置</p><p>使用用法和<code>sort()</code>一样，见上</p><h4 id=stoi><strong>stoi</strong><a hidden class=anchor aria-hidden=true href=#stoi>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>stoi</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>*</span><span class=p>)</span>
</span></span></code></pre></div><p>将对应string类型字符串转换为数字，记忆：<code>s -> t 分别对应两个数据类型的某个字母</code></p><p>注意参数为<code>string</code>字符串类型。</p><p>关于输出数字的范围：</p><ul><li><code>stoi</code><strong>会做</strong>范围检查，默认必须在<code>int</code>范围内，如果超出范围，会出现RE（Runtime Error）错误。</li><li><code>atoi</code><strong>不做</strong>范围检查，如果超出上界，输出上界，超出下界，输出下界</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>string</span> <span class=n>s</span> <span class=o>=</span> <span class=s>&#34;1234&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=n>stoi</span><span class=p>(</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=c1>// 1234
</span></span></span></code></pre></div><h4 id=transform><strong>transform</strong><a hidden class=anchor aria-hidden=true href=#transform>#</a></h4><p>复杂度： O(N)</p><p>作用：使用给定操作，将结果写到dest中</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//原型：
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>transform</span><span class=p>(</span><span class=n>beg</span><span class=p>,</span> <span class=n>end</span><span class=p>,</span> <span class=n>dest</span><span class=p>,</span> <span class=n>unaryOp</span><span class=p>);</span>
</span></span></code></pre></div><p>一般不怎么使用，徒增记忆负担，不如手动实现。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//将序列开始地址beg到结束地址end大小写转换，把结果存到起始地址为dest的序列中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>transform</span><span class=p>(</span><span class=n>beg</span><span class=p>,</span> <span class=n>end</span><span class=p>,</span> <span class=n>dest</span><span class=p>,</span> <span class=o>::</span><span class=n>tolower</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>transform</span><span class=p>(</span><span class=n>beg</span><span class=p>,</span> <span class=n>end</span><span class=p>,</span> <span class=n>dest</span><span class=p>,</span> <span class=o>::</span><span class=n>toupper</span><span class=p>)</span>
</span></span></code></pre></div><h4 id=to_><strong>to_string</strong><a hidden class=anchor aria-hidden=true href=#to_>#</a></h4><p>将数字转化为字符串，支持小数（double）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>12345678</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>to_string</span><span class=p>(</span><span class=n>a</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=sc>&#39;\n&#39;</span><span class=p>;</span>
</span></span></code></pre></div><h4 id=unique><strong>unique</strong><a hidden class=anchor aria-hidden=true href=#unique>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>unique</span><span class=p>(</span><span class=n>beg</span><span class=p>,</span> <span class=n>end</span><span class=p>)</span>
</span></span></code></pre></div><p>复杂度： O(N)</p><p>消除重复元素，返回消除完重复元素的下一个位置的地址</p><p>如：<code>a[] = {1, 3, 2, 3, 6}</code>;</p><p><code>unique</code> 之后 <code>a</code> 数组为<code>{1, 2, 3, 6, 3}</code>前面为无重复元素的数组，后面则是重复元素移到后面，返回<code>a[4]</code>位置的地址（不重复元素的尾后地址）</p><p>消除重复元素一般需要原序列是<strong>有序序列</strong></p><p><strong>应用：离散化</strong>:</p><ul><li><p>方法一：利用数组离散化</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>];</span><span class=c1>//将a数组复制到b数组
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 排序后 b：{1, 2, 3, 3, 6}
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>sort</span><span class=p>(</span><span class=n>b</span><span class=p>,</span> <span class=n>b</span> <span class=o>+</span> <span class=n>n</span><span class=p>);</span><span class=c1>//对b数组排序
</span></span></span><span class=line><span class=cl><span class=c1>// 消除重复元素b：{1, 2, 3, 6, 3} 返回的地址为最后一个元素3的地址 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>len</span> <span class=o>=</span> <span class=n>unique</span><span class=p>(</span><span class=n>b</span><span class=p>,</span> <span class=n>b</span> <span class=o>+</span> <span class=n>n</span><span class=p>)</span> <span class=o>-</span> <span class=n>b</span><span class=p>;</span><span class=c1>//消除 b 的重复元素，并获取长度
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//因为b有序，查找到的下标就是对应的 相对大小（离散化后的值）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>pos</span> <span class=o>=</span> <span class=n>lower_bound</span><span class=p>(</span><span class=n>b</span><span class=p>,</span> <span class=n>b</span> <span class=o>+</span> <span class=n>len</span><span class=p>,</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=o>-</span> <span class=n>b</span><span class=p>;</span><span class=c1>//在b数组中二分查找第一个大于等于a[i]的下标
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>pos</span><span class=p>;</span> <span class=c1>// 离散化赋值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div></li><li><p>方法二：利用 <code>vector</code> 进行离散化</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>a</span><span class=p>(</span><span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>b</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>sort</span><span class=p>(</span><span class=n>b</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>b</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=n>b</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>unique</span><span class=p>(</span><span class=n>b</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>b</span><span class=p>.</span><span class=n>end</span><span class=p>()),</span> <span class=n>b</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>lower_bound</span><span class=p>(</span><span class=n>b</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>b</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> <span class=o>-</span> <span class=n>b</span><span class=p>.</span><span class=n>begin</span><span class=p>()</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// 离散后的数据从1开始   
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div></li></ul><h4 id=__><strong>__gcd</strong><a hidden class=anchor aria-hidden=true href=#__>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>__gcd</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>)</span>
</span></span></code></pre></div><p>求a和b的最大公约数</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>__gcd</span><span class=p>(</span><span class=mi>12</span><span class=p>,</span><span class=mi>15</span><span class=p>)</span> <span class=o>=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=n>__gcd</span><span class=p>(</span><span class=mi>21</span><span class=p>,</span><span class=mi>0</span><span class=p>)</span> <span class=o>=</span> <span class=mi>21</span>
</span></span></code></pre></div><h4 id=__-1><strong>__lg</strong><a hidden class=anchor aria-hidden=true href=#__-1>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>__lg</span><span class=p>(</span><span class=n>a</span><span class=p>)</span>
</span></span></code></pre></div><ol><li>求一个数二进制下最高位位于第几位（从<strong>第0位</strong>开始）（或二进制数下有几位）</li><li><code>__lg(x)</code>相当于返回⌊ log_2 x ⌋</li><li>复杂度O(1)</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>__lg</span><span class=p>(</span><span class=mi>8</span><span class=p>)</span> <span class=o>=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=n>__lg</span><span class=p>(</span><span class=mi>15</span><span class=p>)</span> <span class=o>=</span> <span class=mi>3</span>
</span></span></code></pre></div><h4 id=_builtin>_<strong><em>builtin</em> 内置位运算函数</strong><a hidden class=anchor aria-hidden=true href=#_builtin>#</a></h4><p>需要注意：内置函数有相应的unsigned lnt和unsigned long long版本，unsigned long long只需要在函数名后面加上ll就可以了，比如__builtin_clzll(x) ，默认是32位unsigned int</p><p>很多题目和 long long 数据类型有关，如有需要注意添加 ll</p><h4 id=__-2><strong>__builtin_ffs</strong><a hidden class=anchor aria-hidden=true href=#__-2>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>__builtin_ffs</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
</span></span></code></pre></div><p>二进制中对应最后一位<code>1</code>的位数，比如<code>4</code>会返回<code>3</code>（100）</p><h4 id=__-3><strong>__builtin_popcount</strong><a hidden class=anchor aria-hidden=true href=#__-3>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>__builtin_popcount</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
</span></span></code></pre></div><p><code>x</code>中<code>1</code>的个数</p><h4 id=__-4><strong>__builtin_ctz</strong><a hidden class=anchor aria-hidden=true href=#__-4>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>__builtin_ctz</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
</span></span></code></pre></div><p><code>x</code>末尾<code>0</code>的个数（<code>count tail zero</code>）</p><h4 id=__-5><strong>__builtin_clz</strong><a hidden class=anchor aria-hidden=true href=#__-5>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>__builtin_clz</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
</span></span></code></pre></div><p><code>x</code>前导<code>0</code>的个数（<code>count leading zero</code>）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>__builtin_clz</span><span class=p>(</span><span class=mi>32</span><span class=p>);</span> <span class=c1>// 26
</span></span></span><span class=line><span class=cl><span class=c1>//因为共有6位,默认数据范围为32位，32 - 6 = 26
</span></span></span></code></pre></div><h4 id=__-6><strong>__builtin_parity</strong><a hidden class=anchor aria-hidden=true href=#__-6>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>__builtin_parity</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>x</span><span class=err>`中</span><span class=mi>1</span><span class=err>的个数的奇偶性，</span> <span class=err>奇数输出`</span><span class=mi>1</span><span class=err>`，偶数输出`</span><span class=mi>0</span>
</span></span></code></pre></div><p>可参考链接：</p><ol><li><a href=https://www.luogu.com.cn/blog/AccRobin/grammar-candies>C++语法糖</a> <a href=https://www.luogu.com.cn/blog/AccRobin/grammar-candies>https://www.luogu.com.cn/blog/AccRobin/grammar-candies</a></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/stl/>STL</a></li><li><a href=http://localhost:1313/tags/cpp/>Cpp</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/post/algorithm/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%9801/><span class=title>« 上一页</span><br><span>每日一题01</span>
</a><a class=next href=http://localhost:1313/post/programming-language/stl%E5%AD%A6%E4%B9%A0-06/><span class=title>下一页 »</span><br><span>STL学习 06</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="view on github" href=https://github.com/1-pluto1><svg viewBox="0 0 24 24" fill="currentcolor" height="30" width="30"><path d="M12 0C5.374.0.0 5.373.0 12c0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931.0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176.0.0 1.008-.322 3.301 1.23A11.509 11.509.0 0112 5.803c1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221.0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576C20.566 21.797 24 17.3 24 12c0-6.627-5.373-12-12-12z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share STL学习 07 via email" href="mailto:?subject=STL%E5%AD%A6%E4%B9%A0+07&body=Check out this article: http%3a%2f%2flocalhost%3a1313%2fpost%2fprogramming-language%2fstl%25E5%25AD%25A6%25E4%25B9%25A0-07%2f"><svg viewBox="0 0 24 24" fill="currentcolor" height="30" width="30"><path d="M20 4H4c-1.1.0-1.99.9-1.99 2L2 18c0 1.1.89 2 2 2h16c1.1.0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4-8 5-8-5V6l8 5 8-5v2z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share STL学习 07 on x" href="https://x.com/intent/tweet/?text=STL%e5%ad%a6%e4%b9%a0%2007&amp;url=http%3a%2f%2flocalhost%3a1313%2fpost%2fprogramming-language%2fstl%25E5%25AD%25A6%25E4%25B9%25A0-07%2f&amp;hashtags=STL%2cCpp"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a rel="noopener noreferrer" aria-label="share STL学习 07 on wechat" href=# onclick='return copyToClipboard("http://localhost:1313/post/programming-language/stl%E5%AD%A6%E4%B9%A0-07/"),!1'><svg viewBox="0 0 24 24" fill="currentcolor" height="30" width="30"><path d="M17 10c3.3142.0 6 2.2165 6 4.95C23 16.4867 22.1513 17.8595 20.8182 18.767V21l-2.1426-1.2958C18.1265 19.835 17.5642 19.9007 17 19.9c-3.3142.0-6-2.2165-6-4.95S13.6858 10 17 10zm-6.2343 5.5978C10.033 15.8089 9.24728 15.9231 8.43285 15.9231 7.4893 15.9251 6.55199 15.7679 5.65934 15.4578L3.12367 17V13.9835C1.81018 12.8183 1 11.2223 1 9.46154 1 5.89262 4.3278 3 8.43285 3 12.4487 3 15.7202 5.76769 15.8657 9.23V9.48092M9.49469 7.30769H9.50531m-3.19613.0H6.3198m8.4841 6.46151H14.8145m3.1749.0H18"/></svg></a></li></ul><script>function copyToClipboard(e){navigator.clipboard?navigator.clipboard.writeText(e).then(function(){alert("链接已复制到剪贴板，请在微信中粘贴分享！")}).catch(function(){fallbackCopyToClipboard(e)}):fallbackCopyToClipboard(e)}function fallbackCopyToClipboard(e){var t=document.createElement("textarea");t.value=e,t.style.position="fixed",t.style.left="-999999px",t.style.top="-999999px",document.body.appendChild(t),t.focus(),t.select();try{document.execCommand("copy"),alert("链接已复制到剪贴板，请在微信中粘贴分享！")}catch{alert("复制失败，请手动复制链接: "+e)}document.body.removeChild(t)}</script></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>Pluto's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>
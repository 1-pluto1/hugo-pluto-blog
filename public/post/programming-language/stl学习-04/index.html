<!doctype html><html lang=zh dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>STL学习 04 | Pluto's blog</title>
<meta name=keywords content="STL,Cpp"><meta name=description content="六、map
6.1 介绍
映射类似于函数的对应关系，每一个x对应一个y,而map是每个键对应一个值。和python的字典非常相似。
//头文件
#include<map>
//初始化定义
map<string,string> mp;
map<string,int> mp;
map<int,node> mp;//node是结构体类型
map特性：map会按照键的顺序从小到大自动排序，键的类型必须可以比较大小"><meta name=author content="ZhaoYang"><link rel=canonical href=http://localhost:1313/post/programming-language/stl%E5%AD%A6%E4%B9%A0-04/><link crossorigin=anonymous href=/assets/css/stylesheet.858555f7aa71b704d9e49b3e04281f89b8ea905b374c06d322709cb2c4c85423.css integrity="sha256-hYVV96pxtwTZ5Js+BCgfibjqkFs3TAbTInCcssTIVCM=" rel="preload stylesheet" as=style><link rel=icon href=https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/b_0b65080deefa163507d3aa4c6a7a5e07.jpg><link rel=icon type=image/png sizes=16x16 href=https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/b_0b65080deefa163507d3aa4c6a7a5e07.jpg><link rel=icon type=image/png sizes=32x32 href=https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/b_0b65080deefa163507d3aa4c6a7a5e07.jpg><link rel=apple-touch-icon href=https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/b_0b65080deefa163507d3aa4c6a7a5e07.jpg><link rel=mask-icon href=https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/b_0b65080deefa163507d3aa4c6a7a5e07.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=http://localhost:1313/post/programming-language/stl%E5%AD%A6%E4%B9%A0-04/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/post/programming-language/stl%E5%AD%A6%E4%B9%A0-04/"><meta property="og:site_name" content="Pluto's blog"><meta property="og:title" content="STL学习 04"><meta property="og:description" content="六、map 6.1 介绍 映射类似于函数的对应关系，每一个x对应一个y,而map是每个键对应一个值。和python的字典非常相似。
//头文件 #include<map> //初始化定义 map<string,string> mp; map<string,int> mp; map<int,node> mp;//node是结构体类型 map特性：map会按照键的顺序从小到大自动排序，键的类型必须可以比较大小"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-03-22T11:30:03+00:00"><meta property="article:modified_time" content="2023-03-22T11:30:03+00:00"><meta property="article:tag" content="STL"><meta property="article:tag" content="Cpp"><meta property="og:image" content="http://localhost:1313/opengraph.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/opengraph.webp"><meta name=twitter:title content="STL学习 04"><meta name=twitter:description content="六、map
6.1 介绍
映射类似于函数的对应关系，每一个x对应一个y,而map是每个键对应一个值。和python的字典非常相似。
//头文件
#include<map>
//初始化定义
map<string,string> mp;
map<string,int> mp;
map<int,node> mp;//node是结构体类型
map特性：map会按照键的顺序从小到大自动排序，键的类型必须可以比较大小"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/post/"},{"@type":"ListItem","position":2,"name":"STL学习 04","item":"http://localhost:1313/post/programming-language/stl%E5%AD%A6%E4%B9%A0-04/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"STL学习 04","name":"STL学习 04","description":"六、map 6.1 介绍 映射类似于函数的对应关系，每一个x对应一个y,而map是每个键对应一个值。和python的字典非常相似。\n//头文件 #include\u0026lt;map\u0026gt; //初始化定义 map\u0026lt;string,string\u0026gt; mp; map\u0026lt;string,int\u0026gt; mp; map\u0026lt;int,node\u0026gt; mp;//node是结构体类型 map特性：map会按照键的顺序从小到大自动排序，键的类型必须可以比较大小\n","keywords":["STL","Cpp"],"articleBody":"六、map 6.1 介绍 映射类似于函数的对应关系，每一个x对应一个y,而map是每个键对应一个值。和python的字典非常相似。\n//头文件 #include //初始化定义 map\u003cstring,string\u003e mp; map\u003cstring,int\u003e mp; map\u003cint,node\u003e mp;//node是结构体类型 map特性：map会按照键的顺序从小到大自动排序，键的类型必须可以比较大小\n6.2 函数方法 6.2.1 函数方法 代码 含义 mp.find(key) 返回值为key的映射的迭代器。O(logN)。注意：用find函数来定位数据出现的位置，它返回一个迭代器。当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回map.end() map.erase(it) 删除迭代器对应的键和值O(1) mp.erase(key) 根据映射的键删除键和值O(logN) mp.erase(first,last) 删除左闭右开区间迭代器对应的键和值O(last−first) mp.size() 返回映射的对数O(1) mp.clear() 清空map中的所有元素O ( N ) mp.insert() 插入元素，插入时要构造键值对 mp.empty() 如果map为空，返回true，否则返回false mp.begin() 返回指向map第一个元素的迭代器（地址） mp.end() 返回指向map尾部的迭代器（最后一个元素的下一个地址） mp.rbegin() 返回指向map最后一个元素的迭代器（地址） mp.rend() 返回指向map第一个元素前面(上一个）的逆向迭代器（地址） mp.count(key) 查看元素是否存在，因为map中键是唯一的，所以存在返回1，不存在返回0 mp.lower_bound() 返回一个迭代器，指向键值\u003e= key的第一个元素 mp.upper_bound() 返回一个迭代器，指向键值\u003e key的第一个元素 6.2.2 注意点 下面说明部分函数方法的注意点\n注意： 查找元素是否存在时，可以使用 ①mp.find() ② mp.count() ③ mp[key] 但是第三种情况，如果不存在对应的key时，会自动创建一个键值对（产生一个额外的键值对空间） 所以为了不增加额外的空间负担，最好使用前两种方法\n6.2.3 迭代器进行正反向遍历 mp.begin()和mp.end()用法：\n用于正向遍历map\nmap\u003cint,int\u003e mp; mp[1] = 2; mp[2] = 3; mp[3] = 4; auto it = mp.begin(); while(it != mp.end()) { cout \u003c\u003c it-\u003efirst \u003c\u003c \" \" \u003c\u003c it-\u003esecond \u003c\u003c \"\\n\"; it ++; } 结果：\n1 2 2 3 3 4 mp.rbegin()和mp.rend()\n用于逆向遍历map:\nmap\u003cint,int\u003e mp; mp[1] = 2; mp[2] = 3; mp[3] = 4; auto it = mp.rbegin(); while(it != mp.rend()) { cout \u003c\u003c it-\u003efirst \u003c\u003c \" \" \u003c\u003c it-\u003esecond \u003c\u003c \"\\n\"; it ++; } 结果：\n3 4 2 3 1 2 6.2.4 二分查找 二分查找lower_bound() upper_bound()\nmap的二分查找以第一个元素（即键为准），对键进行二分查找 返回值为map迭代器类型\n#include using namespace std; int main() { map\u003cint, int\u003e m{{1, 2}, {2, 2}, {1, 2}, {8, 2}, {6, 2}};//有序 map\u003cint, int\u003e::iterator it1 = m.lower_bound(2); cout \u003c\u003c it1-\u003efirst \u003c\u003c \"\\n\";//it1-\u003efirst=2 map\u003cint, int\u003e::iterator it2 = m.upper_bound(2); cout \u003c\u003c it2-\u003efirst \u003c\u003c \"\\n\";//it2-\u003efirst=6 return 0; } 6.3 添加元素 //先声明 map\u003cstring, string\u003e mp; 方式一：\nmp[\"学习\"] = \"看书\"; mp[\"玩耍\"] = \"打游戏\"; 方式二：插入元素构造键值对\nmp.insert(make_pair(\"vegetable\",\"蔬菜\")); 方式三：\nmp.insert(pair\u003cstring,string\u003e(\"fruit\",\"水果\")); 方式四:\nmp.insert({\"hahaha\",\"wawawa\"}); 6.4 访问元素 6.4.1 下标访问 (大部分情况用于访问单个元素)\nmp[\"菜哇菜\"] = \"强哇强\"; cout \u003c\u003c mp[\"菜哇菜\"] \u003c\u003c \"\\n\";//只是简写的一个例子，程序并不完整 6.4.2 遍历访问 方式一：迭代器访问\nmap\u003cstring,string\u003e::iterator it; for(it = mp.begin(); it != mp.end(); it++) { // 键 值 // it是结构体指针访问所以要用 -\u003e 访问 cout \u003c\u003c it-\u003efirst \u003c\u003c \" \" \u003c\u003c it-\u003esecond \u003c\u003c \"\\n\"; //*it是结构体变量 访问要用 . 访问 //cout\u003c\u003c(*it).first\u003c\u003c\" \"\u003c\u003c(*it).second; } 方式二：智能指针访问\nfor(auto i : mp) cout \u003c\u003c i.first \u003c\u003c \" \" \u003c\u003c i.second \u003c\u003c endl;//键，值 方式三：对指定单个元素访问\nmap\u003cchar,int\u003e::iterator it = mp.find('a'); cout \u003c\u003c it -\u003e first \u003c\u003c \" \" \u003c\u003c it-\u003esecond \u003c\u003c \"\\n\"; 方式四：c++17特性才具有\nfor(auto [x, y] : mp) cout \u003c\u003c x \u003c\u003c \" \" \u003c\u003c y \u003c\u003c \"\\n\"; //x,y对应键和值 6.5 与unordered_map的比较 这里就不单开一个大目录讲unordered_map了，直接在map里面讲了。\n6.5.1 内部实现原理 map：内部用红黑树实现，具有自动排序（按键从小到大）功能。\nunordered_map：内部用哈希表实现，内部元素无序杂乱。\n6.5.2 效率比较 map：\n优点：内部用红黑树实现，内部元素具有有序性，查询删除等操作复杂度为O ( l o g N ) O(logN)O(logN) 缺点：占用空间，红黑树里每个节点需要保存父子节点和红黑性质等信息，空间占用较大。 unordered_map：\n优点：内部用哈希表实现，查找速度非常快（适用于大量的查询操作）。\n缺点：建立哈希表比较耗时。\n两者方法函数基本一样，差别不大。\n注意：\n随着内部元素越来越多，两种容器的插入删除查询操作的时间都会逐渐变大，效率逐渐变低。\n使用[]查找元素时，如果元素不存在，两种容器都是创建一个空的元素；如果存在，会正常索引对应的值。所以如果查询过多的不存在的元素值，容器内部会创建大量的空的键值对，后续查询创建删除效率会大大降低。\n查询容器内部元素的最优方法是：先判断存在与否，再索引对应值（适用于这两种容器）\n// 以 map 为例 map\u003cint, int\u003e mp; int x = 999999999; if(mp.count(x)) // 此处判断是否存在x这个键 cout \u003c\u003c mp[x] \u003c\u003c \"\\n\"; // 只有存在才会索引对应的值，避免不存在x时多余空元素的创建 另外：\n还有一种映射：multimap\n键可以重复，即一个键对应多个值，如要了解，可以自行搜索。\n七 、set 7.1 介绍 set容器中的元素不会重复，当插入集合中已有的元素时，并不会插入进去，而且set容器里的元素自动从小到大排序。\n即：set里面的元素不重复且有序\n//头文件 #include //初始化定义 set\u003cint\u003e s; 7.2 函数方法 代码 含义 s.begin() 返回set容器的第一个元素的地址（迭代器）O(1) s.end() 返回set容器的最后一个元素的下一个地址（迭代器）O(1) s.rbegin() 返回逆序迭代器，指向容器元素的最后一个位置O(1) s.rend() 返回逆序迭代器吗，指向容器第一个元素前面的位置O(1) s.clear() 删除set容器中的所有的元素，返回unsigned int类型O(N) s.empty() 判断set容器是否为空O(1) s.insert() 插入一个元素 s.size() 返回当前set容器中的元素个数O(1) erase(inerator) 删除定位器iterator指向的值 erase(first,second) 删除定位器first和second之间的值 erase(key_value) 删除键值key_value的值 s.find(element) 查找set中的某一个元素，有则返回该元素对应的迭代器，无则返回结束迭代器 s.count(element) 查找set中的元素出现的个数，由于set中元素唯一，此函数相当于直接询问element是否出现 s.lower_bound(k) 返回大于等于k的第一个元素的迭代器O(logN) s.upper_bound(k) 返回大于k的第一个元素的迭代器O(logN) 7.3 访问 迭代器访问\nfor(set\u003cint\u003e::iterator it = s.begin();it!=s.end();it++) cout \u003c\u003c *it \u003c\u003c \" \"; 智能指针\nfor (auto i : s) cout \u003c\u003c i \u003c\u003c endl; 访问最后一个元素\n//第一种 cout \u003c\u003c *s.rbegin() \u003c\u003c endl; //第二种 set\u003cint\u003e::iterator iter = s.end(); iter--; cout \u003c\u003c (*iter) \u003c\u003c endl; //打印2; //第三种 cout \u003c\u003c *(--s.end()) \u003c\u003c endl; 7.4 重载\u003c运算符 基础数据类型\n方式一：改变set排序规则，set中默认使用less比较器，即从小到大排序。（常用）\nset\u003cint\u003e s1; // 默认从小到大排序 set\u003cint, greater\u003cint\u003e \u003e s2; // 从大到小排序 方式二：重载运算符。（很麻烦，不太常用，没必要）\n//重载 \u003c 运算符 struct cmp { bool operator () (const int\u0026 u, const int\u0026 v) const { // return + 返回条件 return u \u003e v; } }; set\u003cint, cmp\u003e s; for(int i = 1; i \u003c= 10; i++) s.insert(i); for(auto i : s) cout \u003c\u003c i \u003c\u003c \" \"; // 10 9 8 7 6 5 4 3 2 1 方式三：初始化时使用匿名函数定义比较规则\nset\u003cint, function\u003cbool(int, int)\u003e\u003e s([\u0026](int i, int j){ return i \u003e j; // 从大到小 }); for(int i = 1; i \u003c= 10; i++) s.insert(i); for(auto x : s) cout \u003c\u003c x \u003c\u003c \" \"; 高级数据结构（结构体）\n直接重载结构体运算符即可，让结构体可以比较。\nstruct Point { int x, y; bool operator \u003c (const Point \u0026p) const { // 按照点的横坐标从小到大排序,如果横坐标相同,纵坐标从小到大 if(x == p.x) return y \u003c p.y; return x \u003c p.x; } }; set\u003cPoint\u003e s; for(int i = 1; i \u003c= 5; i++) { int x, y; cin \u003e\u003e x \u003e\u003e y; s.insert({x, y}); }\t/* 输入 5 4 5 2 3 7 3 5 4 8 */ for(auto i : s) cout \u003c\u003c i.x \u003c\u003c \" \" \u003c\u003c i.y \u003c\u003c \"\\n\"; /* 输出 3 5 3 7 4 8 5 2 5 4 */ 7.5 其他set multiset:元素可以重复，且元素有序\nunordered_set ：元素无序且只能出现一次\nunordered_multiset ： 元素无序可以出现多次\n八、 pair 8.1 介绍 pair只含有两个元素，可以看作是只有两个元素的结构体\n应用：\n代替二元结构体\n作为map键值对进行插入（代码如下）\nmap\u003cstring, int\u003e mp; mp.insert(pair\u003cstring, int\u003e(\"xingmaqi\",1)); // mp.insert(make_pair(\"xingmaqi\", 1)); // mp.insert({\"xingmaqi\", 1}); 初始化和赋值操作：\n//头文件 #include //1.初始化定义 pair\u003cstring,int\u003e p(\"cailiangwei\",1);//带初始值的 pair\u003cstring,int\u003e p ;//不带初始值的 //2.赋值 p = {\"cai\",18}; p = make_pair(\"wang\", 18); p = pair\u003cstring, int\u003e(\"wang\", 18); 8.2 访问 //定义结构体数组 pair\u003cint,int\u003e p[20]; for(int i = 0;i \u003c 20; i++){ //和结构体相似，first代表第一个元素，second表示第二个元素 cout \u003c\u003c p[i].first \u003c\u003c \" \" \u003c\u003c p[i].second; } ","wordCount":"3249","inLanguage":"zh","image":"http://localhost:1313/opengraph.webp","datePublished":"2023-03-22T11:30:03Z","dateModified":"2023-03-22T11:30:03Z","author":{"@type":"Person","name":"ZhaoYang"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/post/programming-language/stl%E5%AD%A6%E4%B9%A0-04/"},"publisher":{"@type":"Organization","name":"Pluto's blog","logo":{"@type":"ImageObject","url":"https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/b_0b65080deefa163507d3aa4c6a7a5e07.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Pluto (Alt + H)"><img src=https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/null-20a43f960b8c8f08.jpg alt aria-label=logo height=35>Pluto</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/ title=Home><span>Home</span></a></li><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://github.com/1-pluto1/ title=GitHub><span>GitHub</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>主页</a>&nbsp;»&nbsp;<a href=http://localhost:1313/post/>Posts</a></div><h1 class="post-title entry-hint-parent">STL学习 04</h1><div class=post-meta><span title='2023-03-22 11:30:03 +0000 +0000'>2023年03月22日</span>&nbsp;·&nbsp;7 分钟&nbsp;·&nbsp;3249 字&nbsp;·&nbsp;ZhaoYang&nbsp;|&nbsp;<a href=https://github.com/1-pluto1/hugo-pluto-blog/edit/main/content/post/Programming%20Language/STL%e5%ad%a6%e4%b9%a0%2004.md rel="noopener noreferrer edit" target=_blank>Edit on GitHub</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#六map>六、map</a></li><li><a href=#七-set>七 、set</a></li><li><a href=#八-pair>八、 pair</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h3 id=六map>六、map<a hidden class=anchor aria-hidden=true href=#六map>#</a></h3><h4 id=61-介绍>6.1 介绍<a hidden class=anchor aria-hidden=true href=#61-介绍>#</a></h4><p>映射类似于函数的对应关系，每一个<strong>x</strong>对应一个<strong>y</strong>,而<strong>map</strong>是每个键对应一个值。和python的字典非常相似。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//头文件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include&lt;map&gt;
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>//初始化定义
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>map</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>mp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>map</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>mp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span><span class=n>node</span><span class=o>&gt;</span> <span class=n>mp</span><span class=p>;</span><span class=c1>//node是结构体类型
</span></span></span></code></pre></div><p><strong>map特性：map会按照键的顺序从小到大自动排序，键的类型必须可以比较大小</strong></p><h4 id=62-函数方法>6.2 函数方法<a hidden class=anchor aria-hidden=true href=#62-函数方法>#</a></h4><h5 id=621-函数方法>6.2.1 函数方法<a hidden class=anchor aria-hidden=true href=#621-函数方法>#</a></h5><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td>mp.find(key)</td><td>返回值为key的映射的迭代器。O(logN)。注意：用find函数来定位数据出现的位置，它返回一个迭代器。当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回map.end()</td></tr><tr><td>map.erase(it)</td><td>删除迭代器对应的键和值O(1)</td></tr><tr><td>mp.erase(key)</td><td>根据映射的键删除键和值O(logN)</td></tr><tr><td>mp.erase(first,last)</td><td>删除左闭右开区间迭代器对应的键和值O(last−first)</td></tr><tr><td>mp.size()</td><td>返回映射的对数O(1)</td></tr><tr><td>mp.clear()</td><td>清空map中的所有元素O ( N )</td></tr><tr><td>mp.insert()</td><td>插入元素，插入时要构造键值对</td></tr><tr><td>mp.empty()</td><td>如果map为空，返回true，否则返回false</td></tr><tr><td>mp.begin()</td><td>返回指向map第一个元素的迭代器（地址）</td></tr><tr><td>mp.end()</td><td>返回指向map尾部的迭代器（最后一个元素的<strong>下一个</strong>地址）</td></tr><tr><td>mp.rbegin()</td><td>返回指向map最后一个元素的迭代器（地址）</td></tr><tr><td>mp.rend()</td><td>返回指向map第一个元素前面(上一个）的逆向迭代器（地址）</td></tr><tr><td>mp.count(key)</td><td>查看元素是否存在，因为map中键是唯一的，所以存在返回1，不存在返回0</td></tr><tr><td>mp.lower_bound()</td><td>返回一个迭代器，指向键值>= <strong>key</strong>的第一个元素</td></tr><tr><td>mp.upper_bound()</td><td>返回一个迭代器，指向键值> key的第一个元素</td></tr><tr><td></td><td></td></tr></tbody></table><h5 id=622-注意点>6.2.2 注意点<a hidden class=anchor aria-hidden=true href=#622-注意点>#</a></h5><p><strong>下面说明部分函数方法的注意点</strong></p><p>注意：
查找元素是否存在时，可以使用
①<code>mp.find()</code> ② <code>mp.count()</code> ③ <code>mp[key]</code>
但是第三种情况，如果不存在对应的<code>key</code>时，会自动创建一个键值对（产生一个额外的键值对空间）
所以为了不增加额外的空间负担，最好使用前两种方法</p><h5 id=623-迭代器进行正反向遍历>6.2.3 迭代器进行正反向遍历<a hidden class=anchor aria-hidden=true href=#623-迭代器进行正反向遍历>#</a></h5><ul><li><p><code>mp.begin()</code>和<code>mp.end()</code>用法：</p><p><strong>用于正向遍历map</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>mp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>mp</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>mp</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>mp</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>mp</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>while</span><span class=p>(</span><span class=n>it</span> <span class=o>!=</span> <span class=n>mp</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>it</span><span class=o>-&gt;</span><span class=n>first</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>it</span><span class=o>-&gt;</span><span class=n>second</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>it</span> <span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>结果：</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=mi>1</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=mi>2</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=mi>3</span> <span class=mi>4</span>
</span></span></code></pre></div></li><li><p><code>mp.rbegin()</code>和<code>mp.rend()</code></p><p><strong>用于逆向遍历map</strong>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>mp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>mp</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>mp</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>mp</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>mp</span><span class=p>.</span><span class=n>rbegin</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>while</span><span class=p>(</span><span class=n>it</span> <span class=o>!=</span> <span class=n>mp</span><span class=p>.</span><span class=n>rend</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>it</span><span class=o>-&gt;</span><span class=n>first</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>it</span><span class=o>-&gt;</span><span class=n>second</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>it</span> <span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>结果：</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=mi>3</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl><span class=mi>2</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=mi>1</span> <span class=mi>2</span>
</span></span></code></pre></div></li></ul><h5 id=624-二分查找>6.2.4 二分查找<a hidden class=anchor aria-hidden=true href=#624-二分查找>#</a></h5><p>二分查找<code>lower_bound() upper_bound()</code></p><p>map的二分查找以第一个元素（即键为准），对<strong>键</strong>进行二分查找
返回值为map迭代器类型</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include&lt;bits/stdc++.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>m</span><span class=p>{{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>},</span> <span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=mi>2</span><span class=p>},</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>},</span> <span class=p>{</span><span class=mi>8</span><span class=p>,</span> <span class=mi>2</span><span class=p>},</span> <span class=p>{</span><span class=mi>6</span><span class=p>,</span> <span class=mi>2</span><span class=p>}};</span><span class=c1>//有序
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>it1</span> <span class=o>=</span> <span class=n>m</span><span class=p>.</span><span class=n>lower_bound</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>it1</span><span class=o>-&gt;</span><span class=n>first</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span><span class=c1>//it1-&gt;first=2
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>it2</span> <span class=o>=</span> <span class=n>m</span><span class=p>.</span><span class=n>upper_bound</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>it2</span><span class=o>-&gt;</span><span class=n>first</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span><span class=c1>//it2-&gt;first=6
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=63-添加元素>6.3 添加元素<a hidden class=anchor aria-hidden=true href=#63-添加元素>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//先声明
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>map</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span> <span class=n>string</span><span class=o>&gt;</span> <span class=n>mp</span><span class=p>;</span>
</span></span></code></pre></div><ul><li><p><strong>方式一：</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>mp</span><span class=p>[</span><span class=s>&#34;学习&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=s>&#34;看书&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>mp</span><span class=p>[</span><span class=s>&#34;玩耍&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=s>&#34;打游戏&#34;</span><span class=p>;</span>
</span></span></code></pre></div></li><li><p><strong>方式二：插入元素构造键值对</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>mp</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>make_pair</span><span class=p>(</span><span class=s>&#34;vegetable&#34;</span><span class=p>,</span><span class=s>&#34;蔬菜&#34;</span><span class=p>));</span>
</span></span></code></pre></div></li><li><p><strong>方式三：</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>mp</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span><span class=n>string</span><span class=o>&gt;</span><span class=p>(</span><span class=s>&#34;fruit&#34;</span><span class=p>,</span><span class=s>&#34;水果&#34;</span><span class=p>));</span>
</span></span></code></pre></div></li><li><p><strong>方式四:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>mp</span><span class=p>.</span><span class=n>insert</span><span class=p>({</span><span class=s>&#34;hahaha&#34;</span><span class=p>,</span><span class=s>&#34;wawawa&#34;</span><span class=p>});</span>
</span></span></code></pre></div></li></ul><h4 id=64-访问元素>6.4 访问元素<a hidden class=anchor aria-hidden=true href=#64-访问元素>#</a></h4><h5 id=641-下标访问>6.4.1 下标访问<a hidden class=anchor aria-hidden=true href=#641-下标访问>#</a></h5><p>(大部分情况用于访问单个元素)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>mp</span><span class=p>[</span><span class=s>&#34;菜哇菜&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=s>&#34;强哇强&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>mp</span><span class=p>[</span><span class=s>&#34;菜哇菜&#34;</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span><span class=c1>//只是简写的一个例子，程序并不完整
</span></span></span></code></pre></div><h5 id=642-遍历访问>6.4.2 遍历访问<a hidden class=anchor aria-hidden=true href=#642-遍历访问>#</a></h5><ul><li><p>方式一：迭代器访问</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>map</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span><span class=n>string</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>it</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=n>it</span> <span class=o>=</span> <span class=n>mp</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span> <span class=n>it</span> <span class=o>!=</span> <span class=n>mp</span><span class=p>.</span><span class=n>end</span><span class=p>();</span> <span class=n>it</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>//      键                 值 
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// it是结构体指针访问所以要用 -&gt; 访问
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>it</span><span class=o>-&gt;</span><span class=n>first</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>it</span><span class=o>-&gt;</span><span class=n>second</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=c1>//*it是结构体变量 访问要用 . 访问
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//cout&lt;&lt;(*it).first&lt;&lt;&#34; &#34;&lt;&lt;(*it).second;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div></li><li><p>方式二：智能指针访问</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=k>auto</span> <span class=nl>i</span> <span class=p>:</span> <span class=n>mp</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>i</span><span class=p>.</span><span class=n>first</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>i</span><span class=p>.</span><span class=n>second</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span><span class=c1>//键，值
</span></span></span></code></pre></div></li><li><p>方式三：对指定单个元素访问</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>map</span><span class=o>&lt;</span><span class=kt>char</span><span class=p>,</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>it</span> <span class=o>=</span> <span class=n>mp</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=sc>&#39;a&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>it</span> <span class=o>-&gt;</span> <span class=n>first</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span>  <span class=n>it</span><span class=o>-&gt;</span><span class=n>second</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span></code></pre></div></li><li><p>方式四：c++17特性才具有</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=k>auto</span> <span class=p>[</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>]</span> <span class=o>:</span> <span class=n>mp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>x</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>y</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>//x,y对应键和值
</span></span></span></code></pre></div></li></ul><h4 id=65-与unordered_map的比较>6.5 与unordered_map的比较<a hidden class=anchor aria-hidden=true href=#65-与unordered_map的比较>#</a></h4><p>这里就不单开一个大目录讲unordered_map了，直接在map里面讲了。</p><h5 id=651-内部实现原理>6.5.1 内部实现原理<a hidden class=anchor aria-hidden=true href=#651-内部实现原理>#</a></h5><p><strong>map</strong>：内部用<strong>红黑树</strong>实现，具有<strong>自动排序</strong>（按键从小到大）功能。</p><p><strong>unordered_map</strong>：内部用<strong>哈希表</strong>实现，内部元素无序杂乱。</p><h5 id=652-效率比较>6.5.2 效率比较<a hidden class=anchor aria-hidden=true href=#652-效率比较>#</a></h5><p><strong>map：</strong></p><ul><li>优点：内部用红黑树实现，内部元素具有有序性，查询删除等操作复杂度为O ( l o g N ) O(logN)O(logN)</li><li>缺点：占用空间，红黑树里每个节点需要保存父子节点和红黑性质等信息，空间占用较大。</li></ul><p><strong>unordered_map：</strong></p><ul><li><p>优点：内部用哈希表实现，查找速度非常快（适用于大量的查询操作）。</p></li><li><p>缺点：建立哈希表比较耗时。</p></li></ul><p>两者方法函数基本一样，差别不大。</p><p><strong>注意：</strong></p><ul><li><p>随着内部元素越来越多，两种容器的插入删除查询操作的时间都会逐渐变大，效率逐渐变低。</p></li><li><p>使用[]查找元素时，如果元素不存在，两种容器都是创建一个空的元素；如果存在，会正常索引对应的值。所以如果查询过多的不存在的元素值，容器内部会创建大量的空的键值对，后续查询创建删除效率会大大降低。</p></li><li><p>查询容器内部元素的最优方法是：先判断存在与否，再索引对应值（适用于这两种容器）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 以 map 为例
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>mp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>999999999</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span><span class=p>(</span><span class=n>mp</span><span class=p>.</span><span class=n>count</span><span class=p>(</span><span class=n>x</span><span class=p>))</span> <span class=c1>// 此处判断是否存在x这个键
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>mp</span><span class=p>[</span><span class=n>x</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>   <span class=c1>// 只有存在才会索引对应的值，避免不存在x时多余空元素的创建
</span></span></span></code></pre></div></li></ul><p>另外：</p><blockquote><p>还有一种映射：<code>multimap</code></p><p>键可以重复，即一个键对应多个值，如要了解，可以自行搜索。</p></blockquote><h3 id=七-set>七 、set<a hidden class=anchor aria-hidden=true href=#七-set>#</a></h3><h4 id=71-介绍>7.1 介绍<a hidden class=anchor aria-hidden=true href=#71-介绍>#</a></h4><p>set容器中的元素不会重复，当插入集合中已有的元素时，并不会插入进去，而且set容器里的元素自动从小到大排序。</p><p>即：set里面的元素<strong>不重复且有序</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//头文件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include&lt;set&gt;
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>//初始化定义
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>set</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>s</span><span class=p>;</span>
</span></span></code></pre></div><h4 id=72-函数方法>7.2 函数方法<a hidden class=anchor aria-hidden=true href=#72-函数方法>#</a></h4><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td>s.begin()</td><td>返回set容器的第一个元素的地址（迭代器）O(1)</td></tr><tr><td>s.end()</td><td>返回set容器的最后一个元素的下一个地址（迭代器）O(1)</td></tr><tr><td>s.rbegin()</td><td>返回逆序迭代器，指向容器元素的最后一个位置O(1)</td></tr><tr><td>s.rend()</td><td>返回逆序迭代器吗，指向容器第一个元素前面的位置O(1)</td></tr><tr><td>s.clear()</td><td>删除set容器中的所有的元素，返回unsigned int类型O(N)</td></tr><tr><td>s.empty()</td><td>判断set容器是否为空O(1)</td></tr><tr><td>s.insert()</td><td>插入一个元素</td></tr><tr><td>s.size()</td><td>返回当前set容器中的元素个数O(1)</td></tr><tr><td>erase(inerator)</td><td>删除定位器iterator指向的值</td></tr><tr><td>erase(first,second)</td><td>删除定位器first和second之间的值</td></tr><tr><td>erase(key_value)</td><td>删除键值key_value的值</td></tr><tr><td>s.find(element)</td><td>查找set中的某一个元素，有则返回该元素对应的迭代器，无则返回结束迭代器</td></tr><tr><td>s.count(element)</td><td>查找set中的元素出现的个数，由于set中元素唯一，此函数相当于直接询问element是否出现</td></tr><tr><td>s.lower_bound(k)</td><td>返回大于等于k的第一个元素的迭代器O(logN)</td></tr><tr><td>s.upper_bound(k)</td><td>返回大于k的第一个元素的迭代器O(logN)</td></tr><tr><td></td><td></td></tr></tbody></table><h4 id=73-访问>7.3 访问<a hidden class=anchor aria-hidden=true href=#73-访问>#</a></h4><ul><li><p>迭代器访问</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=n>set</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>it</span> <span class=o>=</span> <span class=n>s</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span><span class=n>it</span><span class=o>!=</span><span class=n>s</span><span class=p>.</span><span class=n>end</span><span class=p>();</span><span class=n>it</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=n>it</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span></code></pre></div></li><li><p>智能指针</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=nl>i</span> <span class=p>:</span> <span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>i</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span></code></pre></div></li><li><p>访问最后一个元素</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//第一种
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=n>s</span><span class=p>.</span><span class=n>rbegin</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//第二种
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>set</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>s</span><span class=p>.</span><span class=n>end</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>iter</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=o>*</span><span class=n>iter</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=c1>//打印2;
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//第三种
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=p>(</span><span class=o>--</span><span class=n>s</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span></code></pre></div></li></ul><h4 id=74-重载运算符>7.4 重载&lt;运算符<a hidden class=anchor aria-hidden=true href=#74-重载运算符>#</a></h4><ul><li><p>基础数据类型</p><p>方式一：改变set排序规则，set中默认使用less比较器，即从小到大排序。（常用）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>set</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>s1</span><span class=p>;</span> <span class=c1>// 默认从小到大排序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>set</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>greater</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=n>s2</span><span class=p>;</span> <span class=c1>// 从大到小排序
</span></span></span></code></pre></div><p>方式二：重载运算符。（很麻烦，不太常用，没必要）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//重载 &lt; 运算符
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>cmp</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>operator</span> <span class=p>()</span> <span class=p>(</span><span class=k>const</span> <span class=kt>int</span><span class=o>&amp;</span> <span class=n>u</span><span class=p>,</span> <span class=k>const</span> <span class=kt>int</span><span class=o>&amp;</span> <span class=n>v</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>       <span class=c1>// return + 返回条件
</span></span></span><span class=line><span class=cl><span class=c1></span>       <span class=k>return</span> <span class=n>u</span> <span class=o>&gt;</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>set</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>cmp</span><span class=o>&gt;</span> <span class=n>s</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=mi>10</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=k>auto</span> <span class=nl>i</span> <span class=p>:</span> <span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>i</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// 10 9 8 7 6 5 4 3 2 1
</span></span></span></code></pre></div><p>方式三：初始化时使用匿名函数定义比较规则</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>set</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>function</span><span class=o>&lt;</span><span class=kt>bool</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span><span class=o>&gt;&gt;</span> <span class=n>s</span><span class=p>([</span><span class=o>&amp;</span><span class=p>](</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>i</span> <span class=o>&gt;</span> <span class=n>j</span><span class=p>;</span> <span class=c1>// 从大到小
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>});</span>
</span></span><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=mi>10</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=k>auto</span> <span class=nl>x</span> <span class=p>:</span> <span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>x</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span></code></pre></div></li><li><p>高级数据结构（结构体）</p><p>直接重载结构体运算符即可，让结构体可以比较。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Point</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>bool</span> <span class=k>operator</span> <span class=o>&lt;</span> <span class=p>(</span><span class=k>const</span> <span class=n>Point</span> <span class=o>&amp;</span><span class=n>p</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 按照点的横坐标从小到大排序,如果横坐标相同,纵坐标从小到大
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span><span class=p>(</span><span class=n>x</span> <span class=o>==</span> <span class=n>p</span><span class=p>.</span><span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=n>y</span> <span class=o>&lt;</span> <span class=n>p</span><span class=p>.</span><span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>x</span> <span class=o>&lt;</span> <span class=n>p</span><span class=p>.</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>set</span><span class=o>&lt;</span><span class=n>Point</span><span class=o>&gt;</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=mi>5</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>x</span> <span class=o>&gt;&gt;</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span><span class=p>.</span><span class=n>insert</span><span class=p>({</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>	
</span></span><span class=line><span class=cl><span class=cm>/* 输入
</span></span></span><span class=line><span class=cl><span class=cm>5 4
</span></span></span><span class=line><span class=cl><span class=cm>5 2
</span></span></span><span class=line><span class=cl><span class=cm>3 7
</span></span></span><span class=line><span class=cl><span class=cm>3 5
</span></span></span><span class=line><span class=cl><span class=cm>4 8
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=k>auto</span> <span class=nl>i</span> <span class=p>:</span> <span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>i</span><span class=p>.</span><span class=n>x</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>i</span><span class=p>.</span><span class=n>y</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cm>/* 输出
</span></span></span><span class=line><span class=cl><span class=cm>3 5
</span></span></span><span class=line><span class=cl><span class=cm>3 7
</span></span></span><span class=line><span class=cl><span class=cm>4 8
</span></span></span><span class=line><span class=cl><span class=cm>5 2
</span></span></span><span class=line><span class=cl><span class=cm>5 4
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></div></li></ul><h4 id=75-其他set>7.5 其他set<a hidden class=anchor aria-hidden=true href=#75-其他set>#</a></h4><p><code>multiset</code>:元素可以重复，且元素有序</p><p><code>unordered_set</code> ：元素无序且只能出现一次</p><p><code>unordered_multiset</code> ： 元素无序可以出现多次</p><h3 id=八-pair>八、 pair<a hidden class=anchor aria-hidden=true href=#八-pair>#</a></h3><h4 id=81-介绍>8.1 介绍<a hidden class=anchor aria-hidden=true href=#81-介绍>#</a></h4><p>pair只含有两个元素，可以看作是只有两个元素的结构体</p><p><strong>应用</strong>：</p><ul><li><p>代替二元结构体</p></li><li><p>作为map键值对进行插入（代码如下）</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>map</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>mp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>mp</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=s>&#34;xingmaqi&#34;</span><span class=p>,</span><span class=mi>1</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=c1>// mp.insert(make_pair(&#34;xingmaqi&#34;, 1));
</span></span></span><span class=line><span class=cl><span class=c1>// mp.insert({&#34;xingmaqi&#34;, 1});
</span></span></span></code></pre></div></li></ul><p>初始化和赋值操作：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//头文件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include&lt;utility&gt;
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>//1.初始化定义
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>pair</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>p</span><span class=p>(</span><span class=s>&#34;cailiangwei&#34;</span><span class=p>,</span><span class=mi>1</span><span class=p>);</span><span class=c1>//带初始值的
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>pair</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>p</span> <span class=p>;</span><span class=c1>//不带初始值的
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>//2.赋值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>p</span> <span class=o>=</span> <span class=p>{</span><span class=s>&#34;cai&#34;</span><span class=p>,</span><span class=mi>18</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>=</span> <span class=n>make_pair</span><span class=p>(</span><span class=s>&#34;wang&#34;</span><span class=p>,</span> <span class=mi>18</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>=</span> <span class=n>pair</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=s>&#34;wang&#34;</span><span class=p>,</span> <span class=mi>18</span><span class=p>);</span>
</span></span></code></pre></div><h4 id=82-访问>8.2 访问<a hidden class=anchor aria-hidden=true href=#82-访问>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//定义结构体数组
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>p</span><span class=p>[</span><span class=mi>20</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span><span class=n>i</span> <span class=o>&lt;</span> <span class=mi>20</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=c1>//和结构体相似，first代表第一个元素，second表示第二个元素
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>p</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>first</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>p</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>second</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/stl/>STL</a></li><li><a href=http://localhost:1313/tags/cpp/>Cpp</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/post/programming-language/stl%E5%AD%A6%E4%B9%A0-06/><span class=title>« 上一页</span><br><span>STL学习 06</span>
</a><a class=next href=http://localhost:1313/post/programming-language/stl%E5%AD%A6%E4%B9%A0-05/><span class=title>下一页 »</span><br><span>STL学习 05</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="view on github" href=https://github.com/1-pluto1><svg viewBox="0 0 24 24" fill="currentcolor" height="30" width="30"><path d="M12 0C5.374.0.0 5.373.0 12c0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931.0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176.0.0 1.008-.322 3.301 1.23A11.509 11.509.0 0112 5.803c1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221.0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576C20.566 21.797 24 17.3 24 12c0-6.627-5.373-12-12-12z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share STL学习 04 via email" href="mailto:?subject=STL%E5%AD%A6%E4%B9%A0+04&body=Check out this article: http%3a%2f%2flocalhost%3a1313%2fpost%2fprogramming-language%2fstl%25E5%25AD%25A6%25E4%25B9%25A0-04%2f"><svg viewBox="0 0 24 24" fill="currentcolor" height="30" width="30"><path d="M20 4H4c-1.1.0-1.99.9-1.99 2L2 18c0 1.1.89 2 2 2h16c1.1.0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4-8 5-8-5V6l8 5 8-5v2z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share STL学习 04 on x" href="https://x.com/intent/tweet/?text=STL%e5%ad%a6%e4%b9%a0%2004&amp;url=http%3a%2f%2flocalhost%3a1313%2fpost%2fprogramming-language%2fstl%25E5%25AD%25A6%25E4%25B9%25A0-04%2f&amp;hashtags=STL%2cCpp"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a rel="noopener noreferrer" aria-label="share STL学习 04 on wechat" href=# onclick='return copyToClipboard("http://localhost:1313/post/programming-language/stl%E5%AD%A6%E4%B9%A0-04/"),!1'><svg viewBox="0 0 24 24" fill="currentcolor" height="30" width="30"><path d="M17 10c3.3142.0 6 2.2165 6 4.95C23 16.4867 22.1513 17.8595 20.8182 18.767V21l-2.1426-1.2958C18.1265 19.835 17.5642 19.9007 17 19.9c-3.3142.0-6-2.2165-6-4.95S13.6858 10 17 10zm-6.2343 5.5978C10.033 15.8089 9.24728 15.9231 8.43285 15.9231 7.4893 15.9251 6.55199 15.7679 5.65934 15.4578L3.12367 17V13.9835C1.81018 12.8183 1 11.2223 1 9.46154 1 5.89262 4.3278 3 8.43285 3 12.4487 3 15.7202 5.76769 15.8657 9.23V9.48092M9.49469 7.30769H9.50531m-3.19613.0H6.3198m8.4841 6.46151H14.8145m3.1749.0H18"/></svg></a></li></ul><script>function copyToClipboard(e){navigator.clipboard?navigator.clipboard.writeText(e).then(function(){alert("链接已复制到剪贴板，请在微信中粘贴分享！")}).catch(function(){fallbackCopyToClipboard(e)}):fallbackCopyToClipboard(e)}function fallbackCopyToClipboard(e){var t=document.createElement("textarea");t.value=e,t.style.position="fixed",t.style.left="-999999px",t.style.top="-999999px",document.body.appendChild(t),t.focus(),t.select();try{document.execCommand("copy"),alert("链接已复制到剪贴板，请在微信中粘贴分享！")}catch{alert("复制失败，请手动复制链接: "+e)}document.body.removeChild(t)}</script></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>Pluto's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>
<!doctype html><html lang=zh dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++学习04 | Pluto's blog</title>
<meta name=keywords content="Cpp"><meta name=description content="侯捷C++面向对象编程（上）课程打卡 Day4
8、 静态 模板 namespace
8.1 static
对于非静态的函数和数据：
非静态的成员函数通过this指针来处理不同的数据（一份函数&ndash;>多个对象）


对于静态的函数和数据："><meta name=author content="ZhaoYang"><link rel=canonical href=http://localhost:1313/post/programming-language/c++%E5%AD%A6%E4%B9%A004/><link crossorigin=anonymous href=/assets/css/stylesheet.858555f7aa71b704d9e49b3e04281f89b8ea905b374c06d322709cb2c4c85423.css integrity="sha256-hYVV96pxtwTZ5Js+BCgfibjqkFs3TAbTInCcssTIVCM=" rel="preload stylesheet" as=style><link rel=icon href=https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/b_0b65080deefa163507d3aa4c6a7a5e07.jpg><link rel=icon type=image/png sizes=16x16 href=https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/b_0b65080deefa163507d3aa4c6a7a5e07.jpg><link rel=icon type=image/png sizes=32x32 href=https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/b_0b65080deefa163507d3aa4c6a7a5e07.jpg><link rel=apple-touch-icon href=https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/b_0b65080deefa163507d3aa4c6a7a5e07.jpg><link rel=mask-icon href=https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/b_0b65080deefa163507d3aa4c6a7a5e07.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=http://localhost:1313/post/programming-language/c++%E5%AD%A6%E4%B9%A004/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/post/programming-language/c++%E5%AD%A6%E4%B9%A004/"><meta property="og:site_name" content="Pluto's blog"><meta property="og:title" content="C++学习04"><meta property="og:description" content="侯捷C++面向对象编程（上）课程打卡 Day4 8、 静态 模板 namespace 8.1 static 对于非静态的函数和数据：
非静态的成员函数通过this指针来处理不同的数据（一份函数–>多个对象）
对于静态的函数和数据："><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-03-18T11:30:03+00:00"><meta property="article:modified_time" content="2023-03-18T11:30:03+00:00"><meta property="article:tag" content="Cpp"><meta property="og:image" content="http://localhost:1313/opengraph.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/opengraph.webp"><meta name=twitter:title content="C++学习04"><meta name=twitter:description content="侯捷C++面向对象编程（上）课程打卡 Day4
8、 静态 模板 namespace
8.1 static
对于非静态的函数和数据：
非静态的成员函数通过this指针来处理不同的数据（一份函数&ndash;>多个对象）


对于静态的函数和数据："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/post/"},{"@type":"ListItem","position":2,"name":"C++学习04","item":"http://localhost:1313/post/programming-language/c++%E5%AD%A6%E4%B9%A004/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++学习04","name":"C\u002b\u002b学习04","description":"侯捷C++面向对象编程（上）课程打卡 Day4 8、 静态 模板 namespace 8.1 static 对于非静态的函数和数据：\n非静态的成员函数通过this指针来处理不同的数据（一份函数\u0026ndash;\u0026gt;多个对象）\n对于静态的函数和数据：\n","keywords":["Cpp"],"articleBody":"侯捷C++面向对象编程（上）课程打卡 Day4 8、 静态 模板 namespace 8.1 static 对于非静态的函数和数据：\n非静态的成员函数通过this指针来处理不同的数据（一份函数–\u003e多个对象）\n对于静态的函数和数据：\n静态函数没有this，不能处理一般的数据，只能处理静态的数据。\n例1:\nclass Account { public: static double m_rate; //静态变量的声明 static void set_rate(const double\u0026 x) { m_rate = x; } //静态函数 }; double Account::m_rate = 0; //静态变量的定义 一定要有 int main() { //调用静态函数法1——by class name Account::set_rate(5.0); //调用静态函数法2——by object Account a; a.set_rate(7.0); //静态函数与a无关/无this } 例2：设计模式 Singleton（单体）\n构造函数放在private中，外界无法调用 设计了getInstance静态函数，来生成并返回唯一的一份 8.2 template 可以参考菜鸟教程：\nhttps://www.runoob.com/cplusplus/cpp-templates.html\n模板是泛型编程的基础，泛型编程以一种独立于任何特定类型的方式编写代码。\n模板是创建泛型类或函数的蓝图或者公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。\n8.2.1 函数模板 模板函数的定义的一般形式如下：\ntemplate \u003ctypename type\u003e ret-type funcname(parameter list) { //函数主体 } 在这里，type是函数所使用的数据类型的占位符名称。该名称可以在函数定义中使用。\n接下来给出实例，返回两个数的最大值：\n#include #include using namespace std; template \u003ctypename T\u003e inline T const\u0026 Max (T const\u0026 a, T const\u0026 b) { return a \u003c b ? b:a; } int main () { int i = 39; int j = 20; cout \u003c\u003c \"Max(i, j): \" \u003c\u003c Max(i, j) \u003c\u003c endl; double f1 = 13.5; double f2 = 20.7; cout \u003c\u003c \"Max(f1, f2): \" \u003c\u003c Max(f1, f2) \u003c\u003c endl; string s1 = \"Hello\"; string s2 = \"World\"; cout \u003c\u003c \"Max(s1, s2): \" \u003c\u003c Max(s1, s2) \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果：\nMax(i, j): 39 Max(f1, f2): 20.7 Max(s1, s2): World 8.2.2 类模板 正如我们定义函数模板一样，我们也可以定义类模板。泛型类声明的一般形式如下所示：\ntemplate \u003cclass type\u003e class class-name { . . . } 在这里，type 是占位符类型名称，可以在类被实例化的时候进行指定。您可以使用一个逗号分隔的列表来定义多个泛型数据类型。\n下面的实例定义了类 Stack\u003c\u003e，并实现了泛型方法来对元素进行入栈出栈操作：\n#include #include #include #include #include using namespace std; template \u003cclass T\u003e class Stack { private: vector\u003cT\u003e elems; // 元素 public: void push(T const\u0026); // 入栈 void pop(); // 出栈 T top() const; // 返回栈顶元素 bool empty() const{ // 如果为空则返回真。 return elems.empty(); } }; template \u003cclass T\u003e void Stack\u003cT\u003e::push (T const\u0026 elem) { // 追加传入元素的副本 elems.push_back(elem); } template \u003cclass T\u003e void Stack\u003cT\u003e::pop () { if (elems.empty()) { throw out_of_range(\"Stack\u003c\u003e::pop(): empty stack\"); } // 删除最后一个元素 elems.pop_back(); } template \u003cclass T\u003e T Stack\u003cT\u003e::top () const { if (elems.empty()) { throw out_of_range(\"Stack\u003c\u003e::top(): empty stack\"); } // 返回最后一个元素的副本 return elems.back(); } int main() { try { Stack\u003cint\u003e intStack; // int 类型的栈 Stack\u003cstring\u003e stringStack; // string 类型的栈 // 操作 int 类型的栈 intStack.push(7); cout \u003c\u003c intStack.top() \u003c\u003cendl; // 操作 string 类型的栈 stringStack.push(\"hello\"); cout \u003c\u003c stringStack.top() \u003c\u003c std::endl; stringStack.pop(); stringStack.pop(); } catch (exception const\u0026 ex) { cerr \u003c\u003c \"Exception: \" \u003c\u003c ex.what() \u003c\u003cendl; return -1; } } 当上面的代码被编译和执行时，它会产生下列结果：\n7 hello Exception: Stack\u003c\u003e::pop(): empty stack 8.3 namespace 命名空间被用于作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。\n定义命名空间\n命名空间的定义使用关键字namespace,后跟命名空间的名称。如下图所示：\nnamespace namespace_name{ //代码声明 } 为了调节带有命名空间的函数或变量，需要在前面加上命名空间的名称。如下图所示：\nname::code;//code可以是变量或者函数 using 指令\n可以使用using namespace指令，这样在使用命名空间的时候就可以不用在前面加上命名空间的名称。该指令会告诉编译器，后续的代码使用指定的命名空间的名称。\nusing 指令也可以用来指定命名空间中的特定项目。例如，如果您只打算使用 std 命名空间中的 cout 部分，您可以使用如下的语句：\nusing std::cout; 随后的代码中，在使用 cout 时就可以不用加上命名空间名称作为前缀，但是 std 命名空间中的其他项目仍然需要加上命名空间名称作为前缀\nusing 指令引入的名称遵循正常的范围规则。名称从使用 using 指令开始是可见的，直到该范围结束。此时，在范围以外定义的同名实体是隐藏的。\n不连续的命名空间\n命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的各个组成部分可以分散在多个文件中。\n所以，如果命名空间中的某个组成部分需要请求定义在另一个文件中的名称，则仍然需要声明该名称。下面的命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素：\nnamespace namespace_name { // 代码声明 } 嵌套的命名空间\n命名空间可以嵌套，您可以在一个命名空间中定义另一个命名空间.\n9、复合 委托 9.1 Composition 复合 类似于C语言中的结构里面可以有结构—class里面也可以有class\ndeque 是一个已经存在的功能很多的类（两头进出的队列）；利用deque的功能来实现queue的多种操作\n该例只是复合的一种情况——设计模式 Adapter\n9.1.1 复合下的构造和析构 构造是由内而外\nContainer 的构造函数，编译器会自动先调用 Component 的 default 构造函数，再执行自己\n注意如果要调用 Component 的其他构造函数需要自己写出来Container::Container(…): Component() { … }; 析构是由外而内\nContainer 的析构函数会先执行自己，之后编译器调用 Component 的析构函数\n9.2 Delegation 委托 委托就是 Composition by reference；即通过指针把任务委托给另一个类\n复合中，内部和外部是一起出现的；而委托是不同步的\n这是一个著名的设计模式——pimpl (pointer to implementation) 或者叫 “编译防火墙”\n右边怎么变动都不会影响左边\nreference counting 多个指针共享一个 “Hello”；但当a要改变内容时， 系统会单独复制一份出来给a来改，b和c依然在共享\n10 继承与多态 10.1 Inheritance 继承 面向对象程序设计的最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序更加容易。也达到了重用代码功能和提高执行效率的效果。\n当创建一个类时，不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。\n继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。\n代码如下：\n// 基类 class Animal { // eat() 函数 // sleep() 函数 }; //派生类 class Dog : public Animal { // bark() 函数 }; 10.1.1 基类 \u0026 派生类 一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：\nclass derived-class: access-specifier base-class 其中，访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。\n10.1.2 访问控制和继承 派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。\n我们可以根据访问权限总结出不同的访问类型，如下所示：\n访问 public protected private 同一个类 yes yes yes 派生类 yes yes no 外部的类 yes no no 一个派生类继承了所有的基类方法，但下列情况除外：\n基类的构造函数、析构函数和拷贝构造函数。 基类的重载运算符。 基类的友元函数。 10.1.3 继承类型 当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。\n我们几乎不使用 protected 或 private 继承，通常使用 public 继承。当使用不同类型的继承时，遵循以下几个规则：\n公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。 保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。 私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。 如下图所示：\n基类 public 成员 基类 protected 成员 基类 private 成员 public 继承 public 成员 protected 成员 不能访问 protected 继承 protected 成员 protected 成员 不能访问 private 继承 private 成员 private 成员 不能访问 10.1.4 多继承 多继承即一个子类可以有多个父类，它继承了多个父类的特性。\nC++ 类可以从多个类继承成员，语法如下：\nclass \u003c派生类名\u003e:\u003c继承方式1\u003e\u003c基类名1\u003e,\u003c继承方式2\u003e\u003c基类名2\u003e,… { \u003c派生类类体\u003e }; 其中，访问修饰符继承方式是 public、protected 或 private 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。\n示例：\n#include using namespace std; // 基类 Shape class Shape { public: void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; // 基类 PaintCost class PaintCost { public: int getCost(int area) { return area * 70; } }; // 派生类 class Rectangle: public Shape, public PaintCost { public: int getArea() { return (width * height); } }; int main(void) { Rectangle Rect; int area; Rect.setWidth(5); Rect.setHeight(7); area = Rect.getArea(); // 输出对象的面积 cout \u003c\u003c \"Total area: \" \u003c\u003c Rect.getArea() \u003c\u003c endl; // 输出总花费 cout \u003c\u003c \"Total paint cost: $\" \u003c\u003c Rect.getCost(area) \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果：\nTotal area: 35 Total paint cost: $2450 10.2 多态与虚函数 10.2.1 多态 多态按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。\nC++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。\n如下例：\n#include using namespace std; class Shape { protected: int width, height; public: Shape( int a=0, int b=0) { width = a; height = b; } int area() { cout \u003c\u003c \"Parent class area :\" \u003c\u003cendl; return 0; } }; class Rectangle: public Shape{ public: Rectangle( int a=0, int b=0):Shape(a, b) { } int area () { cout \u003c\u003c \"Rectangle class area :\" \u003c\u003cendl; return (width * height); } }; class Triangle: public Shape{ public: Triangle( int a=0, int b=0):Shape(a, b) { } int area () { cout \u003c\u003c \"Triangle class area :\" \u003c\u003cendl; return (width * height / 2); } }; // 程序的主函数 int main( ) { Shape *shape; Rectangle rec(10,7); Triangle tri(10,5); // 存储矩形的地址 shape = \u0026rec; // 调用矩形的求面积函数 area shape-\u003earea(); // 存储三角形的地址 shape = \u0026tri; // 调用三角形的求面积函数 area shape-\u003earea(); return 0; } 当上面的代码被编译和执行时，它会产生下列结果：\nParent class area : Parent class area : 导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的静态多态，或静态链接 - 函数调用在程序执行前就准备好了。有时候这也被称为早绑定，因为 area() 函数在程序编译期间就已经设置好了。\n但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 virtual，如下所示：\nclass Shape { protected: int width, height; public: Shape( int a=0, int b=0) { width = a; height = b; } virtual int area() { cout \u003c\u003c \"Parent class area :\" \u003c\u003cendl; return 0; } }; 修改后，当编译和执行前面的实例代码时，它会产生以下结果：\nRectangle class area : Triangle class area : 此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数。\n正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是多态的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。\n10.2.2 虚函数\n虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。\n我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。\npure virtual 函数：\nderived class 一定要重新定义 (override 覆写) 它；其没有定义只有声明\n语法：virtual xxxxxx =0;\n= 0 告诉编译器，函数没有主体，上面的虚函数是纯虚函数。\nvirtual 函数：\nderived class 可以重新定义 (override, 覆写) 它，且它已有默认定义\n语法：virtual xxxxxx;\nnon-virtual 函数：\n不希望 derived class 重新定义 (override, 覆写) 它\n","wordCount":"4281","inLanguage":"zh","image":"http://localhost:1313/opengraph.webp","datePublished":"2023-03-18T11:30:03Z","dateModified":"2023-03-18T11:30:03Z","author":{"@type":"Person","name":"ZhaoYang"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/post/programming-language/c++%E5%AD%A6%E4%B9%A004/"},"publisher":{"@type":"Organization","name":"Pluto's blog","logo":{"@type":"ImageObject","url":"https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/b_0b65080deefa163507d3aa4c6a7a5e07.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Pluto (Alt + H)"><img src=https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/null-20a43f960b8c8f08.jpg alt aria-label=logo height=35>Pluto</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/ title=Home><span>Home</span></a></li><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://github.com/1-pluto1/ title=GitHub><span>GitHub</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>主页</a>&nbsp;»&nbsp;<a href=http://localhost:1313/post/>Posts</a></div><h1 class="post-title entry-hint-parent">C++学习04</h1><div class=post-meta><span title='2023-03-18 11:30:03 +0000 +0000'>2023年03月18日</span>&nbsp;·&nbsp;9 分钟&nbsp;·&nbsp;4281 字&nbsp;·&nbsp;ZhaoYang&nbsp;|&nbsp;<a href=https://github.com/1-pluto1/hugo-pluto-blog/edit/main/content/post/Programming%20Language/C++%e5%ad%a6%e4%b9%a004.md rel="noopener noreferrer edit" target=_blank>Edit on GitHub</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#侯捷c面向对象编程上课程打卡-day4>侯捷C++面向对象编程（上）课程打卡 Day4</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h3 id=侯捷c面向对象编程上课程打卡-day4>侯捷C++面向对象编程（上）课程打卡 Day4<a hidden class=anchor aria-hidden=true href=#侯捷c面向对象编程上课程打卡-day4>#</a></h3><h4 id=8-静态-模板-namespace>8、 静态 模板 namespace<a hidden class=anchor aria-hidden=true href=#8-静态-模板-namespace>#</a></h4><h5 id=81-static>8.1 static<a hidden class=anchor aria-hidden=true href=#81-static>#</a></h5><p>对于非静态的函数和数据：</p><p>非静态的成员函数通过<strong>this</strong>指针来处理不同的数据（一份函数&ndash;>多个对象）</p><p><img alt=img loading=lazy src=https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2023-08-02/image-20230731154446361.png></p><p><img alt=image-20230731154548833 loading=lazy src=https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2023-07-31/image-20230731154548833.png></p><p>对于静态的函数和数据：</p><p>静态函数没有<strong>this</strong>，不能处理一般的数据，只能处理静态的数据。</p><p>例1:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Account</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=k>static</span> <span class=kt>double</span> <span class=n>m_rate</span><span class=p>;</span>  <span class=c1>//静态变量的声明
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>static</span> <span class=kt>void</span> <span class=nf>set_rate</span><span class=p>(</span><span class=k>const</span> <span class=kt>double</span><span class=o>&amp;</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span> <span class=n>m_rate</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span> <span class=p>}</span> <span class=c1>//静态函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=n>Account</span><span class=o>::</span><span class=n>m_rate</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>//静态变量的定义 一定要有
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//调用静态函数法1——by class name
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>Account</span><span class=o>::</span><span class=n>set_rate</span><span class=p>(</span><span class=mf>5.0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//调用静态函数法2——by object
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>Account</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>a</span><span class=p>.</span><span class=n>set_rate</span><span class=p>(</span><span class=mf>7.0</span><span class=p>);</span> <span class=c1>//静态函数与a无关/无this
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>例2：设计模式 <code>Singleton</code>（单体）</p><p><img alt=image-20230731163117925 loading=lazy src=https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2023-07-31/image-20230731163117925.png></p><ul><li>构造函数放在private中，外界无法调用</li><li>设计了<code>getInstance</code>静态函数，来生成并返回唯一的一份</li></ul><h5 id=82-template>8.2 template<a hidden class=anchor aria-hidden=true href=#82-template>#</a></h5><p>可以参考菜鸟教程：</p><p><a href=https://www.runoob.com/cplusplus/cpp-templates.html>https://www.runoob.com/cplusplus/cpp-templates.html</a></p><hr><p>模板是泛型编程的基础，泛型编程以一种独立于任何特定类型的方式编写代码。</p><p>模板是创建泛型类或函数的蓝图或者公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。</p><h6 id=821-函数模板>8.2.1 函数模板<a hidden class=anchor aria-hidden=true href=#821-函数模板>#</a></h6><p>模板函数的定义的一般形式如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>type</span><span class=o>&gt;</span> <span class=n>ret</span><span class=o>-</span><span class=n>type</span> <span class=n>funcname</span><span class=p>(</span><span class=n>parameter</span> <span class=n>list</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//函数主体
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>在这里，type是函数所使用的数据类型的占位符名称。该名称可以在函数定义中使用。</p><p>接下来给出实例，返回两个数的最大值：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span> 
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kr>inline</span> <span class=n>T</span> <span class=k>const</span><span class=o>&amp;</span> <span class=n>Max</span> <span class=p>(</span><span class=n>T</span> <span class=k>const</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>,</span> <span class=n>T</span> <span class=k>const</span><span class=o>&amp;</span> <span class=n>b</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>&lt;</span> <span class=n>b</span> <span class=o>?</span> <span class=nl>b</span><span class=p>:</span><span class=n>a</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span> <span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>39</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Max(i, j): &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>Max</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>f1</span> <span class=o>=</span> <span class=mf>13.5</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>f2</span> <span class=o>=</span> <span class=mf>20.7</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Max(f1, f2): &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>Max</span><span class=p>(</span><span class=n>f1</span><span class=p>,</span> <span class=n>f2</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>s1</span> <span class=o>=</span> <span class=s>&#34;Hello&#34;</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>s2</span> <span class=o>=</span> <span class=s>&#34;World&#34;</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Max(s1, s2): &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>Max</span><span class=p>(</span><span class=n>s1</span><span class=p>,</span> <span class=n>s2</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>当上面的代码被编译和执行时，它会产生下列结果：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Max</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>)</span><span class=o>:</span> <span class=mi>39</span>
</span></span><span class=line><span class=cl><span class=n>Max</span><span class=p>(</span><span class=n>f1</span><span class=p>,</span> <span class=n>f2</span><span class=p>)</span><span class=o>:</span> <span class=mf>20.7</span>
</span></span><span class=line><span class=cl><span class=n>Max</span><span class=p>(</span><span class=n>s1</span><span class=p>,</span> <span class=n>s2</span><span class=p>)</span><span class=o>:</span> <span class=n>World</span>
</span></span></code></pre></div><h6 id=822-类模板>8.2.2 类模板<a hidden class=anchor aria-hidden=true href=#822-类模板>#</a></h6><p>正如我们定义函数模板一样，我们也可以定义类模板。泛型类声明的一般形式如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>type</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>class</span><span class=o>-</span><span class=n>name</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>.</span>
</span></span><span class=line><span class=cl><span class=p>.</span>
</span></span><span class=line><span class=cl><span class=p>.</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在这里，<strong>type</strong> 是占位符类型名称，可以在类被实例化的时候进行指定。您可以使用一个逗号分隔的列表来定义多个泛型数据类型。</p><p>下面的实例定义了类 Stack&lt;>，并实现了泛型方法来对元素进行入栈出栈操作：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;cstdlib&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdexcept&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span> 
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Stack</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>  <span class=k>private</span><span class=o>:</span> 
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>elems</span><span class=p>;</span>     <span class=c1>// 元素 
</span></span></span><span class=line><span class=cl><span class=c1></span> 
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span> 
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>push</span><span class=p>(</span><span class=n>T</span> <span class=k>const</span><span class=o>&amp;</span><span class=p>);</span>  <span class=c1>// 入栈
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>pop</span><span class=p>();</span>               <span class=c1>// 出栈
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>T</span> <span class=nf>top</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>            <span class=c1>// 返回栈顶元素
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>bool</span> <span class=nf>empty</span><span class=p>()</span> <span class=k>const</span><span class=p>{</span>       <span class=c1>// 如果为空则返回真。
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=n>elems</span><span class=p>.</span><span class=n>empty</span><span class=p>();</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span> 
</span></span><span class=line><span class=cl><span class=p>};</span> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Stack</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>push</span> <span class=p>(</span><span class=n>T</span> <span class=k>const</span><span class=o>&amp;</span> <span class=n>elem</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=c1>// 追加传入元素的副本
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>elems</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>elem</span><span class=p>);</span>    
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Stack</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>pop</span> <span class=p>()</span> 
</span></span><span class=line><span class=cl><span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>elems</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=nf>out_of_range</span><span class=p>(</span><span class=s>&#34;Stack&lt;&gt;::pop()</span><span class=o>:</span> <span class=n>empty</span> <span class=n>stack</span><span class=s>&#34;)</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 删除最后一个元素
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>elems</span><span class=p>.</span><span class=n>pop_back</span><span class=p>();</span>         
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>T</span> <span class=n>Stack</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>top</span> <span class=p>()</span> <span class=k>const</span> 
</span></span><span class=line><span class=cl><span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>elems</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=nf>out_of_range</span><span class=p>(</span><span class=s>&#34;Stack&lt;&gt;::top()</span><span class=o>:</span> <span class=n>empty</span> <span class=n>stack</span><span class=s>&#34;)</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 返回最后一个元素的副本 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>elems</span><span class=p>.</span><span class=n>back</span><span class=p>();</span>      
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> 
</span></span><span class=line><span class=cl><span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>        <span class=n>Stack</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span>         <span class=n>intStack</span><span class=p>;</span>  <span class=c1>// int 类型的栈 
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Stack</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>stringStack</span><span class=p>;</span>    <span class=c1>// string 类型的栈 
</span></span></span><span class=line><span class=cl><span class=c1></span> 
</span></span><span class=line><span class=cl>        <span class=c1>// 操作 int 类型的栈 
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>intStack</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=mi>7</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>intStack</span><span class=p>.</span><span class=n>top</span><span class=p>()</span> <span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>        <span class=c1>// 操作 string 类型的栈 
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>stringStack</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=s>&#34;hello&#34;</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>stringStack</span><span class=p>.</span><span class=n>top</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>        <span class=n>stringStack</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span> 
</span></span><span class=line><span class=cl>        <span class=n>stringStack</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span> 
</span></span><span class=line><span class=cl>    <span class=k>catch</span> <span class=p>(</span><span class=n>exception</span> <span class=k>const</span><span class=o>&amp;</span> <span class=n>ex</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>        <span class=n>cerr</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Exception: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>ex</span><span class=p>.</span><span class=n>what</span><span class=p>()</span> <span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>当上面的代码被编译和执行时，它会产生下列结果：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=mi>7</span>
</span></span><span class=line><span class=cl><span class=n>hello</span>
</span></span><span class=line><span class=cl><span class=nl>Exception</span><span class=p>:</span> <span class=n>Stack</span><span class=o>&lt;&gt;::</span><span class=n>pop</span><span class=p>()</span><span class=o>:</span> <span class=n>empty</span> <span class=n>stack</span>
</span></span></code></pre></div><h5 id=83-namespace>8.3 namespace<a hidden class=anchor aria-hidden=true href=#83-namespace>#</a></h5><p>命名空间被用于作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。</p><p><strong>定义命名空间</strong></p><p>命名空间的定义使用关键字<strong>namespace</strong>,后跟命名空间的名称。如下图所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>namespace</span> <span class=n>namespace_name</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=c1>//代码声明
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>为了调节带有命名空间的函数或变量，需要在前面加上命名空间的名称。如下图所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>name</span><span class=o>::</span><span class=n>code</span><span class=p>;</span><span class=c1>//code可以是变量或者函数
</span></span></span></code></pre></div><p><strong>using 指令</strong></p><p>可以使用using namespace指令，这样在使用命名空间的时候就可以不用在前面加上命名空间的名称。该指令会告诉编译器，后续的代码使用指定的命名空间的名称。</p><p>using 指令也可以用来指定命名空间中的特定项目。例如，如果您只打算使用 std 命名空间中的 cout 部分，您可以使用如下的语句：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=p>;</span>
</span></span></code></pre></div><p>随后的代码中，在使用 cout 时就可以不用加上命名空间名称作为前缀，但是 <strong>std</strong> 命名空间中的其他项目仍然需要加上命名空间名称作为前缀</p><p><strong>using</strong> 指令引入的名称遵循正常的范围规则。名称从使用 <strong>using</strong> 指令开始是可见的，直到该范围结束。此时，在范围以外定义的同名实体是隐藏的。</p><p><strong>不连续的命名空间</strong></p><p>命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的各个组成部分可以分散在多个文件中。</p><p>所以，如果命名空间中的某个组成部分需要请求定义在另一个文件中的名称，则仍然需要声明该名称。下面的命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>namespace</span> <span class=n>namespace_name</span> <span class=p>{</span>   <span class=c1>// 代码声明 }
</span></span></span></code></pre></div><p><strong>嵌套的命名空间</strong></p><p>命名空间可以嵌套，您可以在一个命名空间中定义另一个命名空间.</p><h4 id=9复合-委托>9、复合 委托<a hidden class=anchor aria-hidden=true href=#9复合-委托>#</a></h4><h5 id=91-composition-复合>9.1 Composition 复合<a hidden class=anchor aria-hidden=true href=#91-composition-复合>#</a></h5><p>类似于C语言中的结构里面可以有结构&mdash;class里面也可以有class</p><p><img alt=image-20230801093748678 loading=lazy src=https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2023-08-02/image-20230801093748678.png></p><p><code>deque</code> 是一个已经存在的功能很多的类（两头进出的队列）；利用<code>deque</code>的功能来实现<code>queue</code>的多种操作</p><blockquote><p>该例只是复合的一种情况——设计模式 <strong>Adapter</strong></p></blockquote><h6 id=911-复合下的构造和析构>9.1.1 复合下的构造和析构<a hidden class=anchor aria-hidden=true href=#911-复合下的构造和析构>#</a></h6><p><img alt=image-20230801095529359 loading=lazy src=https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2023-08-01/image-20230801095529359.png></p><ul><li><p>构造是由内而外</p><p>Container 的构造函数，编译器会自动先调用 Component 的 default 构造函数，再执行自己</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=err>注意如果要调用</span> <span class=n>Component</span> <span class=err>的其他构造函数需要自己写出来</span><span class=n>Container</span><span class=o>::</span><span class=n>Container</span><span class=p>(</span><span class=err>…</span><span class=p>)</span><span class=o>:</span> <span class=n>Component</span><span class=p>()</span> <span class=p>{</span> <span class=err>…</span> <span class=p>};</span>
</span></span></code></pre></div></li><li><p>析构是由外而内</p><p>Container 的析构函数会先执行自己，之后编译器调用 Component 的析构函数</p></li></ul><h5 id=92-delegation-委托>9.2 Delegation 委托<a hidden class=anchor aria-hidden=true href=#92-delegation-委托>#</a></h5><p>委托就是 Composition by reference；即通过指针把任务委托给另一个类</p><p><img alt=img loading=lazy src=https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2023-08-01/image-20230801101359560.png></p><p>复合中，内部和外部是一起出现的；而委托是不同步的</p><p>这是一个著名的设计模式——pimpl (pointer to implementation) 或者叫 “编译防火墙”</p><ul><li><p>右边怎么变动都不会影响左边</p></li><li><p>reference counting 多个指针共享一个 “Hello”；但当a要改变内容时， 系统会单独复制一份出来给a来改，b和c依然在共享</p></li></ul><p><img alt=image-20230801101907977 loading=lazy src=https://raw.githubusercontent.com/PLUS-WAVE/blog-image/master/img/blog/2023-08-01/image-20230801101907977.png></p><h4 id=10-继承与多态>10 继承与多态<a hidden class=anchor aria-hidden=true href=#10-继承与多态>#</a></h4><h5 id=101-inheritance-继承>10.1 Inheritance 继承<a hidden class=anchor aria-hidden=true href=#101-inheritance-继承>#</a></h5><p>面向对象程序设计的最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序更加容易。也达到了重用代码功能和提高执行效率的效果。</p><p>当创建一个类时，不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为<strong>基类</strong>，新建的类称为<strong>派生类</strong>。</p><p>继承代表了 <strong>is a</strong> 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。</p><p>代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 基类
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Animal</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// eat() 函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// sleep() 函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//派生类
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Dog</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Animal</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// bark() 函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><h6 id=1011-基类--派生类>10.1.1 基类 & 派生类<a hidden class=anchor aria-hidden=true href=#1011-基类--派生类>#</a></h6><p>一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>derived</span><span class=o>-</span><span class=k>class</span><span class=err>: </span><span class=nc>access</span><span class=o>-</span><span class=n>specifier</span> <span class=n>base</span><span class=o>-</span><span class=k>class</span>
</span></span></code></pre></div><p>其中，访问修饰符 access-specifier 是 <strong>public、protected</strong> 或 <strong>private</strong> 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。</p><h6 id=1012-访问控制和继承>10.1.2 访问控制和继承<a hidden class=anchor aria-hidden=true href=#1012-访问控制和继承>#</a></h6><p>派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。</p><p>我们可以根据访问权限总结出不同的访问类型，如下所示：</p><table><thead><tr><th style=text-align:left>访问</th><th style=text-align:left>public</th><th style=text-align:left>protected</th><th style=text-align:left>private</th></tr></thead><tbody><tr><td style=text-align:left>同一个类</td><td style=text-align:left>yes</td><td style=text-align:left>yes</td><td style=text-align:left>yes</td></tr><tr><td style=text-align:left>派生类</td><td style=text-align:left>yes</td><td style=text-align:left>yes</td><td style=text-align:left>no</td></tr><tr><td style=text-align:left>外部的类</td><td style=text-align:left>yes</td><td style=text-align:left>no</td><td style=text-align:left>no</td></tr></tbody></table><p>一个派生类继承了所有的基类方法，但下列情况除外：</p><ul><li>基类的构造函数、析构函数和拷贝构造函数。</li><li>基类的重载运算符。</li><li>基类的友元函数。</li></ul><h6 id=1013-继承类型>10.1.3 继承类型<a hidden class=anchor aria-hidden=true href=#1013-继承类型>#</a></h6><p>当一个类派生自基类，该基类可以被继承为 <strong>public、protected</strong> 或 <strong>private</strong> 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。</p><p>我们几乎不使用 <strong>protected</strong> 或 <strong>private</strong> 继承，通常使用 <strong>public</strong> 继承。当使用不同类型的继承时，遵循以下几个规则：</p><ul><li><strong>公有继承（public）：<strong>当一个类派生自</strong>公有</strong>基类时，基类的<strong>公有</strong>成员也是派生类的<strong>公有</strong>成员，基类的<strong>保护</strong>成员也是派生类的<strong>保护</strong>成员，基类的<strong>私有</strong>成员不能直接被派生类访问，但是可以通过调用基类的<strong>公有</strong>和<strong>保护</strong>成员来访问。</li><li><strong>保护继承（protected）：</strong> 当一个类派生自<strong>保护</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>保护</strong>成员。</li><li><strong>私有继承（private）：<strong>当一个类派生自</strong>私有</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>私有</strong>成员。</li></ul><p>如下图所示：</p><table><thead><tr><th></th><th>基类 public 成员</th><th>基类 protected 成员</th><th>基类 private 成员</th></tr></thead><tbody><tr><td>public 继承</td><td>public 成员</td><td>protected 成员</td><td>不能访问</td></tr><tr><td>protected 继承</td><td>protected 成员</td><td>protected 成员</td><td>不能访问</td></tr><tr><td>private 继承</td><td>private 成员</td><td>private 成员</td><td>不能访问</td></tr></tbody></table><h6 id=1014-多继承>10.1.4 多继承<a hidden class=anchor aria-hidden=true href=#1014-多继承>#</a></h6><p>多继承即一个子类可以有多个父类，它继承了多个父类的特性。</p><p>C++ 类可以从多个类继承成员，语法如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=err>&lt;派生类名</span><span class=o>&gt;:&lt;</span><span class=err>继承方式</span><span class=mi>1</span><span class=o>&gt;&lt;</span><span class=err>基类名</span><span class=mi>1</span><span class=o>&gt;</span><span class=p>,</span><span class=o>&lt;</span><span class=err>继承方式</span><span class=mi>2</span><span class=o>&gt;&lt;</span><span class=err>基类名</span><span class=mi>2</span><span class=o>&gt;</span><span class=p>,</span><span class=err>…</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=err>派生类类体</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>其中，访问修饰符继承方式是 <strong>public、protected</strong> 或 <strong>private</strong> 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。</p><p>示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span> 
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1>// 基类 Shape
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Shape</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=kt>void</span> <span class=n>setWidth</span><span class=p>(</span><span class=kt>int</span> <span class=n>w</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=n>width</span> <span class=o>=</span> <span class=n>w</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=kt>void</span> <span class=nf>setHeight</span><span class=p>(</span><span class=kt>int</span> <span class=n>h</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=n>height</span> <span class=o>=</span> <span class=n>h</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=kt>int</span> <span class=n>width</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=kt>int</span> <span class=n>height</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1>// 基类 PaintCost
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>PaintCost</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=kt>int</span> <span class=n>getCost</span><span class=p>(</span><span class=kt>int</span> <span class=n>area</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=n>area</span> <span class=o>*</span> <span class=mi>70</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1>// 派生类
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Rectangle</span><span class=o>:</span> <span class=k>public</span> <span class=n>Shape</span><span class=p>,</span> <span class=k>public</span> <span class=n>PaintCost</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=kt>int</span> <span class=n>getArea</span><span class=p>()</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span> 
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=p>(</span><span class=n>width</span> <span class=o>*</span> <span class=n>height</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=n>Rectangle</span> <span class=n>Rect</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=kt>int</span> <span class=n>area</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>   <span class=n>Rect</span><span class=p>.</span><span class=n>setWidth</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>   <span class=n>Rect</span><span class=p>.</span><span class=n>setHeight</span><span class=p>(</span><span class=mi>7</span><span class=p>);</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>   <span class=n>area</span> <span class=o>=</span> <span class=n>Rect</span><span class=p>.</span><span class=n>getArea</span><span class=p>();</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>   <span class=c1>// 输出对象的面积
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Total area: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>Rect</span><span class=p>.</span><span class=n>getArea</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>   <span class=c1>// 输出总花费
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Total paint cost: $&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>Rect</span><span class=p>.</span><span class=n>getCost</span><span class=p>(</span><span class=n>area</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>当上面的代码被编译和执行时，它会产生下列结果：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Total</span> <span class=nl>area</span><span class=p>:</span> <span class=mi>35</span>
</span></span><span class=line><span class=cl><span class=n>Total</span> <span class=n>paint</span> <span class=nl>cost</span><span class=p>:</span> <span class=err>$</span><span class=mi>2450</span>
</span></span></code></pre></div><h5 id=102-多态与虚函数>10.2 多态与虚函数<a hidden class=anchor aria-hidden=true href=#102-多态与虚函数>#</a></h5><h6 id=1021-多态>10.2.1 多态<a hidden class=anchor aria-hidden=true href=#1021-多态>#</a></h6><p><strong>多态</strong>按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。</p><p>C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p><p>如下例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp> 
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Shape</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=kt>int</span> <span class=n>width</span><span class=p>,</span> <span class=n>height</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=n>Shape</span><span class=p>(</span> <span class=kt>int</span> <span class=n>a</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=n>width</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>         <span class=n>height</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=kt>int</span> <span class=nf>area</span><span class=p>()</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Parent class area :&#34;</span> <span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Rectangle</span><span class=o>:</span> <span class=k>public</span> <span class=n>Shape</span><span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=n>Rectangle</span><span class=p>(</span> <span class=kt>int</span> <span class=n>a</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span><span class=o>:</span><span class=n>Shape</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=kt>int</span> <span class=nf>area</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span> 
</span></span><span class=line><span class=cl>         <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Rectangle class area :&#34;</span> <span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=p>(</span><span class=n>width</span> <span class=o>*</span> <span class=n>height</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Triangle</span><span class=o>:</span> <span class=k>public</span> <span class=n>Shape</span><span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=n>Triangle</span><span class=p>(</span> <span class=kt>int</span> <span class=n>a</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span><span class=o>:</span><span class=n>Shape</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=kt>int</span> <span class=nf>area</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span> 
</span></span><span class=line><span class=cl>         <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Triangle class area :&#34;</span> <span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=p>(</span><span class=n>width</span> <span class=o>*</span> <span class=n>height</span> <span class=o>/</span> <span class=mi>2</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// 程序的主函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span> <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=n>Shape</span> <span class=o>*</span><span class=n>shape</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=n>Rectangle</span> <span class=n>rec</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span><span class=mi>7</span><span class=p>);</span>
</span></span><span class=line><span class=cl>   <span class=n>Triangle</span>  <span class=n>tri</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>   <span class=c1>// 存储矩形的地址
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=n>shape</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>rec</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=c1>// 调用矩形的求面积函数 area
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=n>shape</span><span class=o>-&gt;</span><span class=n>area</span><span class=p>();</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>   <span class=c1>// 存储三角形的地址
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=n>shape</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>tri</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=c1>// 调用三角形的求面积函数 area
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=n>shape</span><span class=o>-&gt;</span><span class=n>area</span><span class=p>();</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>当上面的代码被编译和执行时，它会产生下列结果：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Parent</span> <span class=k>class</span> <span class=nc>area</span> <span class=o>:</span>
</span></span><span class=line><span class=cl><span class=n>Parent</span> <span class=k>class</span> <span class=nc>area</span> <span class=o>:</span>
</span></span></code></pre></div><p>导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的<strong>静态多态</strong>，或<strong>静态链接</strong> - 函数调用在程序执行前就准备好了。有时候这也被称为<strong>早绑定</strong>，因为 area() 函数在程序编译期间就已经设置好了。</p><p>但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 <strong>virtual</strong>，如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Shape</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=kt>int</span> <span class=n>width</span><span class=p>,</span> <span class=n>height</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=n>Shape</span><span class=p>(</span> <span class=kt>int</span> <span class=n>a</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=n>width</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>         <span class=n>height</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=k>virtual</span> <span class=kt>int</span> <span class=nf>area</span><span class=p>()</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Parent class area :&#34;</span> <span class=o>&lt;&lt;</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>修改后，当编译和执行前面的实例代码时，它会产生以下结果：</p><pre tabindex=0><code>Rectangle class area :
Triangle class area :
</code></pre><p>此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数。</p><p>正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是<strong>多态</strong>的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。</p><p>10.2.2 虚函数</p><p><strong>虚函数</strong> 是在基类中使用关键字 <strong>virtual</strong> 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</p><p>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为<strong>动态链接</strong>，或<strong>后期绑定</strong>。</p><ul><li><p>pure virtual 函数：</p><p>derived class 一定要重新定义 (override 覆写) 它；其没有定义只有声明</p><p>语法：virtual xxxxxx =0;</p><p>= 0 告诉编译器，函数没有主体，上面的虚函数是<strong>纯虚函数</strong>。</p></li><li><p>virtual 函数：</p><p>derived class 可以重新定义 (override, 覆写) 它，且它已有默认定义</p><p>语法：virtual xxxxxx;</p></li><li><p>non-virtual 函数：</p><p>不希望 derived class 重新定义 (override, 覆写) 它</p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/cpp/>Cpp</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/post/programming-language/c++%E5%AD%A6%E4%B9%A006/><span class=title>« 上一页</span><br><span>C++学习06</span>
</a><a class=next href=http://localhost:1313/post/programming-language/c++%E5%AD%A6%E4%B9%A003/><span class=title>下一页 »</span><br><span>C++学习03</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="view on github" href=https://github.com/1-pluto1><svg viewBox="0 0 24 24" fill="currentcolor" height="30" width="30"><path d="M12 0C5.374.0.0 5.373.0 12c0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931.0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176.0.0 1.008-.322 3.301 1.23A11.509 11.509.0 0112 5.803c1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221.0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576C20.566 21.797 24 17.3 24 12c0-6.627-5.373-12-12-12z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++学习04 via email" href="mailto:?subject=C%2B%2B%E5%AD%A6%E4%B9%A004&body=Check out this article: http%3a%2f%2flocalhost%3a1313%2fpost%2fprogramming-language%2fc%2b%2b%25E5%25AD%25A6%25E4%25B9%25A004%2f"><svg viewBox="0 0 24 24" fill="currentcolor" height="30" width="30"><path d="M20 4H4c-1.1.0-1.99.9-1.99 2L2 18c0 1.1.89 2 2 2h16c1.1.0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4-8 5-8-5V6l8 5 8-5v2z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share C++学习04 on x" href="https://x.com/intent/tweet/?text=C%2b%2b%e5%ad%a6%e4%b9%a004&amp;url=http%3a%2f%2flocalhost%3a1313%2fpost%2fprogramming-language%2fc%2b%2b%25E5%25AD%25A6%25E4%25B9%25A004%2f&amp;hashtags=Cpp"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a rel="noopener noreferrer" aria-label="share C++学习04 on wechat" href=# onclick='return copyToClipboard("http://localhost:1313/post/programming-language/c++%E5%AD%A6%E4%B9%A004/"),!1'><svg viewBox="0 0 24 24" fill="currentcolor" height="30" width="30"><path d="M17 10c3.3142.0 6 2.2165 6 4.95C23 16.4867 22.1513 17.8595 20.8182 18.767V21l-2.1426-1.2958C18.1265 19.835 17.5642 19.9007 17 19.9c-3.3142.0-6-2.2165-6-4.95S13.6858 10 17 10zm-6.2343 5.5978C10.033 15.8089 9.24728 15.9231 8.43285 15.9231 7.4893 15.9251 6.55199 15.7679 5.65934 15.4578L3.12367 17V13.9835C1.81018 12.8183 1 11.2223 1 9.46154 1 5.89262 4.3278 3 8.43285 3 12.4487 3 15.7202 5.76769 15.8657 9.23V9.48092M9.49469 7.30769H9.50531m-3.19613.0H6.3198m8.4841 6.46151H14.8145m3.1749.0H18"/></svg></a></li></ul><script>function copyToClipboard(e){navigator.clipboard?navigator.clipboard.writeText(e).then(function(){alert("链接已复制到剪贴板，请在微信中粘贴分享！")}).catch(function(){fallbackCopyToClipboard(e)}):fallbackCopyToClipboard(e)}function fallbackCopyToClipboard(e){var t=document.createElement("textarea");t.value=e,t.style.position="fixed",t.style.left="-999999px",t.style.top="-999999px",document.body.appendChild(t),t.focus(),t.select();try{document.execCommand("copy"),alert("链接已复制到剪贴板，请在微信中粘贴分享！")}catch{alert("复制失败，请手动复制链接: "+e)}document.body.removeChild(t)}</script></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>Pluto's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>